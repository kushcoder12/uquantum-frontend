var Bn = Object.defineProperty;
var Hn = (n, e, t) => e in n ? Bn(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var T = (n, e, t) => Hn(n, typeof e != "symbol" ? e + "" : e, t);
function M(n) {
  if (typeof n == "number")
    return (Math.abs(n * 2654435761) >>> 0).toString(16);
  if (typeof n == "boolean") return n ? "1" : "0";
  if (n === null) return "null";
  if (n === void 0) return "undefined";
  if (typeof n == "string") {
    let e = 2166136261;
    for (let t = 0; t < n.length; t++)
      e ^= n.charCodeAt(t), e += (e << 1) + (e << 4) + (e << 7) + (e << 8) + (e << 24), e = e >>> 0;
    return e.toString(16);
  }
  if (Array.isArray(n)) {
    let e = 2166136261;
    for (let t = 0; t < n.length; t++) {
      e ^= (t + 1) * 2654435761;
      const r = M(n[t]);
      for (let s = 0; s < r.length; s++)
        e ^= r.charCodeAt(s), e *= 16777619, e = e >>> 0;
    }
    return e.toString(16);
  }
  if (typeof n == "object") {
    let e = 2166136261;
    const t = Object.keys(n).sort();
    for (let r = 0; r < t.length; r++) {
      const s = t[r], i = M(s);
      e ^= parseInt(i, 16), e *= 16777619, e = e >>> 0;
      const o = M(n[s]);
      e ^= parseInt(o, 16), e *= 16777619, e = e >>> 0;
    }
    return e.toString(16);
  }
  return M(String(n));
}
const I = {
  Remove: "remove",
  Replace: "replace",
  Add: "add"
}, nn = Symbol.for("__MUTATIVE_PROXY_DRAFT__"), Jn = Symbol("__MUTATIVE_RAW_RETURN_SYMBOL__"), Se = Symbol.iterator, F = {
  mutable: "mutable",
  immutable: "immutable"
}, ot = {};
function le(n, e) {
  return n instanceof Map ? n.has(e) : Object.prototype.hasOwnProperty.call(n, e);
}
function At(n, e) {
  if (e in n) {
    let t = Reflect.getPrototypeOf(n);
    for (; t; ) {
      const r = Reflect.getOwnPropertyDescriptor(t, e);
      if (r)
        return r;
      t = Reflect.getPrototypeOf(t);
    }
  }
}
function at(n) {
  return Object.getPrototypeOf(n) === Set.prototype;
}
function ct(n) {
  return Object.getPrototypeOf(n) === Map.prototype;
}
function N(n) {
  var e;
  return (e = n.copy) !== null && e !== void 0 ? e : n.original;
}
function Y(n) {
  return !!A(n);
}
function A(n) {
  return typeof n != "object" ? null : n == null ? void 0 : n[nn];
}
function ut(n) {
  var e;
  const t = A(n);
  return t ? (e = t.copy) !== null && e !== void 0 ? e : t.original : n;
}
function z(n, e) {
  if (!n || typeof n != "object")
    return !1;
  let t;
  return Object.getPrototypeOf(n) === Object.prototype || Array.isArray(n) || n instanceof Map || n instanceof Set || !!(e != null && e.mark) && ((t = e.mark(n, F)) === F.immutable || typeof t == "function");
}
function rn(n, e = []) {
  if (Object.hasOwnProperty.call(n, "key")) {
    const t = n.parent.copy, r = A(B(t, n.key));
    if (r !== null && (r == null ? void 0 : r.original) !== n.original)
      return null;
    const s = n.parent.type === 3, i = s ? Array.from(n.parent.setMap.keys()).indexOf(n.key) : n.key;
    if (!(s && t.size > i || le(t, i)))
      return null;
    e.push(i);
  }
  if (n.parent)
    return rn(n.parent, e);
  e.reverse();
  try {
    Yn(n.copy, e);
  } catch {
    return null;
  }
  return e;
}
function Z(n) {
  return Array.isArray(n) ? 1 : n instanceof Map ? 2 : n instanceof Set ? 3 : 0;
}
function B(n, e) {
  return Z(n) === 2 ? n.get(e) : n[e];
}
function ye(n, e, t) {
  Z(n) === 2 ? n.set(e, t) : n[e] = t;
}
function xe(n, e) {
  const t = A(n);
  return (t ? N(t) : n)[e];
}
function G(n, e) {
  return n === e ? n !== 0 || 1 / n === 1 / e : n !== n && e !== e;
}
function Ke(n) {
  if (n)
    for (; n.finalities.revoke.length > 0; )
      n.finalities.revoke.pop()();
}
function J(n, e) {
  return e ? n : [""].concat(n).map((t) => {
    const r = `${t}`;
    return r.indexOf("/") === -1 && r.indexOf("~") === -1 ? r : r.replace(/~/g, "~0").replace(/\//g, "~1");
  }).join("/");
}
function Yn(n, e) {
  for (let t = 0; t < e.length - 1; t += 1) {
    const r = e[t];
    if (n = B(Z(n) === 3 ? Array.from(n) : n, r), typeof n != "object")
      throw new Error(`Cannot resolve patch at '${e.join("/")}'.`);
  }
  return n;
}
function Zn(n) {
  const e = Object.create(Object.getPrototypeOf(n));
  return Reflect.ownKeys(n).forEach((t) => {
    let r = Reflect.getOwnPropertyDescriptor(n, t);
    if (r.enumerable && r.configurable && r.writable) {
      e[t] = n[t];
      return;
    }
    r.writable || (r.writable = !0, r.configurable = !0), (r.get || r.set) && (r = {
      configurable: !0,
      writable: !0,
      enumerable: r.enumerable,
      value: n[t]
    }), Reflect.defineProperty(e, t, r);
  }), e;
}
const Xn = Object.prototype.propertyIsEnumerable;
function sn(n, e) {
  let t;
  if (Array.isArray(n))
    return Array.prototype.concat.call(n);
  if (n instanceof Set) {
    if (!at(n)) {
      const r = Object.getPrototypeOf(n).constructor;
      return new r(n.values());
    }
    return Set.prototype.difference ? Set.prototype.difference.call(n, /* @__PURE__ */ new Set()) : new Set(n.values());
  } else if (n instanceof Map) {
    if (!ct(n)) {
      const r = Object.getPrototypeOf(n).constructor;
      return new r(n);
    }
    return new Map(n);
  } else if (e != null && e.mark && (t = e.mark(n, F), t !== void 0) && t !== F.mutable) {
    if (t === F.immutable)
      return Zn(n);
    if (typeof t == "function") {
      if (e.enablePatches || e.enableAutoFreeze)
        throw new Error("You can't use mark and patches or auto freeze together.");
      return t();
    }
    throw new Error(`Unsupported mark result: ${t}`);
  } else if (typeof n == "object" && Object.getPrototypeOf(n) === Object.prototype) {
    const r = {};
    return Object.keys(n).forEach((s) => {
      r[s] = n[s];
    }), Object.getOwnPropertySymbols(n).forEach((s) => {
      Xn.call(n, s) && (r[s] = n[s]);
    }), r;
  } else
    throw new Error("Please check mark() to ensure that it is a stable marker draftable function.");
}
function $(n) {
  n.copy || (n.copy = sn(n.original, n.options));
}
function ae(n) {
  if (!z(n))
    return ut(n);
  if (Array.isArray(n))
    return n.map(ae);
  if (n instanceof Map) {
    const t = Array.from(n.entries()).map(([r, s]) => [
      r,
      ae(s)
    ]);
    if (!ct(n)) {
      const r = Object.getPrototypeOf(n).constructor;
      return new r(t);
    }
    return new Map(t);
  }
  if (n instanceof Set) {
    const t = Array.from(n).map(ae);
    if (!at(n)) {
      const r = Object.getPrototypeOf(n).constructor;
      return new r(t);
    }
    return new Set(t);
  }
  const e = Object.create(Object.getPrototypeOf(n));
  for (const t in n)
    e[t] = ae(n[t]);
  return e;
}
function Ae(n) {
  return Y(n) ? ae(n) : n;
}
function Q(n) {
  var e;
  n.assignedMap = (e = n.assignedMap) !== null && e !== void 0 ? e : /* @__PURE__ */ new Map(), n.operated || (n.operated = !0, n.parent && Q(n.parent));
}
function Ot() {
  throw new Error("Cannot modify frozen object");
}
function ee(n, e, t, r, s) {
  {
    t = t ?? /* @__PURE__ */ new WeakMap(), r = r ?? [], s = s ?? [];
    const o = t.has(n) ? t.get(n) : n;
    if (r.length > 0) {
      const a = r.indexOf(o);
      if (o && typeof o == "object" && a !== -1)
        throw r[0] === o ? new Error("Forbids circular reference") : new Error(`Forbids circular reference: ~/${s.slice(0, a).map((c, u) => {
          if (typeof c == "symbol")
            return `[${c.toString()}]`;
          const l = r[u];
          return typeof c == "object" && (l instanceof Map || l instanceof Set) ? Array.from(l.keys()).indexOf(c) : c;
        }).join("/")}`);
      r.push(o), s.push(e);
    } else
      r.push(o);
  }
  if (Object.isFrozen(n) || Y(n)) {
    r.pop(), s.pop();
    return;
  }
  switch (Z(n)) {
    case 2:
      for (const [a, c] of n)
        ee(a, a, t, r, s), ee(c, a, t, r, s);
      n.set = n.clear = n.delete = Ot;
      break;
    case 3:
      for (const a of n)
        ee(a, a, t, r, s);
      n.add = n.clear = n.delete = Ot;
      break;
    case 1:
      Object.freeze(n);
      let o = 0;
      for (const a of n)
        ee(a, o, t, r, s), o += 1;
      break;
    default:
      Object.freeze(n), Object.keys(n).forEach((a) => {
        const c = n[a];
        ee(c, a, t, r, s);
      });
  }
  r.pop(), s.pop();
}
function lt(n, e) {
  const t = Z(n);
  if (t === 0)
    Reflect.ownKeys(n).forEach((r) => {
      e(r, n[r], n);
    });
  else if (t === 1) {
    let r = 0;
    for (const s of n)
      e(r, s, n), r += 1;
  } else
    n.forEach((r, s) => e(s, r, n));
}
function on(n, e, t) {
  if (Y(n) || !z(n, t) || e.has(n) || Object.isFrozen(n))
    return;
  const r = n instanceof Set, s = r ? /* @__PURE__ */ new Map() : void 0;
  if (e.add(n), lt(n, (i, o) => {
    var a;
    if (Y(o)) {
      const c = A(o);
      $(c);
      const u = !((a = c.assignedMap) === null || a === void 0) && a.size || c.operated ? c.copy : c.original;
      ye(r ? s : n, i, u);
    } else
      on(o, e, t);
  }), s) {
    const i = n, o = Array.from(i);
    i.clear(), o.forEach((a) => {
      i.add(s.has(a) ? s.get(a) : a);
    });
  }
}
function er(n, e) {
  const t = n.type === 3 ? n.setMap : n.copy;
  n.finalities.revoke.length > 1 && n.assignedMap.get(e) && t && on(B(t, e), n.finalities.handledSet, n.options);
}
function ze(n) {
  n.type === 3 && n.copy && (n.copy.clear(), n.setMap.forEach((e) => {
    n.copy.add(ut(e));
  }));
}
function Ve(n, e, t, r) {
  if (n.operated && n.assignedMap && n.assignedMap.size > 0 && !n.finalized) {
    if (t && r) {
      const i = rn(n);
      i && e(n, i, t, r);
    }
    n.finalized = !0;
  }
}
function ft(n, e, t, r) {
  const s = A(t);
  s && (s.callbacks || (s.callbacks = []), s.callbacks.push((i, o) => {
    var a;
    const c = n.type === 3 ? n.setMap : n.copy;
    if (G(B(c, e), t)) {
      let u = s.original;
      s.copy && (u = s.copy), ze(n), Ve(n, r, i, o), n.options.enableAutoFreeze && (n.options.updatedValues = (a = n.options.updatedValues) !== null && a !== void 0 ? a : /* @__PURE__ */ new WeakMap(), n.options.updatedValues.set(u, s.original)), ye(c, e, u);
    }
  }), n.options.enableAutoFreeze && s.finalities !== n.finalities && (n.options.enableAutoFreeze = !1)), z(t, n.options) && n.finalities.draft.push(() => {
    const i = n.type === 3 ? n.setMap : n.copy;
    G(B(i, e), t) && er(n, e);
  });
}
function tr(n, e, t, r, s) {
  let { original: i, assignedMap: o, options: a } = n, c = n.copy;
  c.length < i.length && ([i, c] = [c, i], [t, r] = [r, t]);
  for (let u = 0; u < i.length; u += 1)
    if (o.get(u.toString()) && c[u] !== i[u]) {
      const l = e.concat([u]), f = J(l, s);
      t.push({
        op: I.Replace,
        path: f,
        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
        value: Ae(c[u])
      }), r.push({
        op: I.Replace,
        path: f,
        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
        value: Ae(i[u])
      });
    }
  for (let u = i.length; u < c.length; u += 1) {
    const l = e.concat([u]), f = J(l, s);
    t.push({
      op: I.Add,
      path: f,
      // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
      value: Ae(c[u])
    });
  }
  if (i.length < c.length) {
    const { arrayLengthAssignment: u = !0 } = a.enablePatches;
    if (u) {
      const l = e.concat(["length"]), f = J(l, s);
      r.push({
        op: I.Replace,
        path: f,
        value: i.length
      });
    } else
      for (let l = c.length; i.length < l; l -= 1) {
        const f = e.concat([l - 1]), d = J(f, s);
        r.push({
          op: I.Remove,
          path: d
        });
      }
  }
}
function nr({ original: n, copy: e, assignedMap: t }, r, s, i, o) {
  t.forEach((a, c) => {
    const u = B(n, c), l = Ae(B(e, c)), f = a ? le(n, c) ? I.Replace : I.Add : I.Remove;
    if (G(u, l) && f === I.Replace)
      return;
    const d = r.concat(c), h = J(d, o);
    s.push(f === I.Remove ? { op: f, path: h } : { op: f, path: h, value: l }), i.push(f === I.Add ? { op: I.Remove, path: h } : f === I.Remove ? { op: I.Add, path: h, value: u } : { op: I.Replace, path: h, value: u });
  });
}
function rr({ original: n, copy: e }, t, r, s, i) {
  let o = 0;
  n.forEach((a) => {
    if (!e.has(a)) {
      const c = t.concat([o]), u = J(c, i);
      r.push({
        op: I.Remove,
        path: u,
        value: a
      }), s.unshift({
        op: I.Add,
        path: u,
        value: a
      });
    }
    o += 1;
  }), o = 0, e.forEach((a) => {
    if (!n.has(a)) {
      const c = t.concat([o]), u = J(c, i);
      r.push({
        op: I.Add,
        path: u,
        value: a
      }), s.unshift({
        op: I.Remove,
        path: u,
        value: a
      });
    }
    o += 1;
  });
}
function he(n, e, t, r) {
  const { pathAsArray: s = !0 } = n.options.enablePatches;
  switch (n.type) {
    case 0:
    case 2:
      return nr(n, e, t, r, s);
    case 1:
      return tr(n, e, t, r, s);
    case 3:
      return rr(n, e, t, r, s);
  }
}
const ve = (n, e, t = !1) => {
  if (typeof n == "object" && n !== null && (!z(n, e) || t))
    throw new Error("Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.");
}, Qe = {
  get size() {
    return N(A(this)).size;
  },
  has(n) {
    return N(A(this)).has(n);
  },
  set(n, e) {
    const t = A(this), r = N(t);
    return (!r.has(n) || !G(r.get(n), e)) && ($(t), Q(t), t.assignedMap.set(n, !0), t.copy.set(n, e), ft(t, n, e, he)), this;
  },
  delete(n) {
    if (!this.has(n))
      return !1;
    const e = A(this);
    return $(e), Q(e), e.original.has(n) ? e.assignedMap.set(n, !1) : e.assignedMap.delete(n), e.copy.delete(n), !0;
  },
  clear() {
    const n = A(this);
    if (this.size) {
      $(n), Q(n), n.assignedMap = /* @__PURE__ */ new Map();
      for (const [e] of n.original)
        n.assignedMap.set(e, !1);
      n.copy.clear();
    }
  },
  forEach(n, e) {
    const t = A(this);
    N(t).forEach((r, s) => {
      n.call(e, this.get(s), s, this);
    });
  },
  get(n) {
    var e, t;
    const r = A(this), s = N(r).get(n), i = ((t = (e = r.options).mark) === null || t === void 0 ? void 0 : t.call(e, s, F)) === F.mutable;
    if (r.options.strict && ve(s, r.options, i), i || r.finalized || !z(s, r.options) || s !== r.original.get(n))
      return s;
    const o = ot.createDraft({
      original: s,
      parentDraft: r,
      key: n,
      finalities: r.finalities,
      options: r.options
    });
    return $(r), r.copy.set(n, o), o;
  },
  keys() {
    return N(A(this)).keys();
  },
  values() {
    const n = this.keys();
    return {
      [Se]: () => this.values(),
      next: () => {
        const e = n.next();
        return e.done ? e : {
          done: !1,
          value: this.get(e.value)
        };
      }
    };
  },
  entries() {
    const n = this.keys();
    return {
      [Se]: () => this.entries(),
      next: () => {
        const e = n.next();
        if (e.done)
          return e;
        const t = this.get(e.value);
        return {
          done: !1,
          value: [e.value, t]
        };
      }
    };
  },
  [Se]() {
    return this.entries();
  }
}, sr = Reflect.ownKeys(Qe), vt = (n, e, { isValuesIterator: t }) => () => {
  var r, s;
  const i = e.next();
  if (i.done)
    return i;
  const o = i.value;
  let a = n.setMap.get(o);
  const c = A(a), u = ((s = (r = n.options).mark) === null || s === void 0 ? void 0 : s.call(r, a, F)) === F.mutable;
  if (n.options.strict && ve(o, n.options, u), !u && !c && z(o, n.options) && !n.finalized && n.original.has(o)) {
    const l = ot.createDraft({
      original: o,
      parentDraft: n,
      key: o,
      finalities: n.finalities,
      options: n.options
    });
    n.setMap.set(o, l), a = l;
  } else c && (a = c.proxy);
  return {
    done: !1,
    value: t ? a : [a, a]
  };
}, ke = {
  get size() {
    return A(this).setMap.size;
  },
  has(n) {
    const e = A(this);
    if (e.setMap.has(n))
      return !0;
    $(e);
    const t = A(n);
    return !!(t && e.setMap.has(t.original));
  },
  add(n) {
    const e = A(this);
    return this.has(n) || ($(e), Q(e), e.assignedMap.set(n, !0), e.setMap.set(n, n), ft(e, n, n, he)), this;
  },
  delete(n) {
    if (!this.has(n))
      return !1;
    const e = A(this);
    $(e), Q(e);
    const t = A(n);
    return t && e.setMap.has(t.original) ? (e.assignedMap.set(t.original, !1), e.setMap.delete(t.original)) : (!t && e.setMap.has(n) ? e.assignedMap.set(n, !1) : e.assignedMap.delete(n), e.setMap.delete(n));
  },
  clear() {
    if (!this.size)
      return;
    const n = A(this);
    $(n), Q(n);
    for (const e of n.original)
      n.assignedMap.set(e, !1);
    n.setMap.clear();
  },
  values() {
    const n = A(this);
    $(n);
    const e = n.setMap.keys();
    return {
      [Symbol.iterator]: () => this.values(),
      next: vt(n, e, { isValuesIterator: !0 })
    };
  },
  entries() {
    const n = A(this);
    $(n);
    const e = n.setMap.keys();
    return {
      [Symbol.iterator]: () => this.entries(),
      next: vt(n, e, {
        isValuesIterator: !1
      })
    };
  },
  keys() {
    return this.values();
  },
  [Se]() {
    return this.values();
  },
  forEach(n, e) {
    const t = this.values();
    let r = t.next();
    for (; !r.done; )
      n.call(e, r.value, r.value, this), r = t.next();
  }
};
Set.prototype.difference && Object.assign(ke, {
  intersection(n) {
    return Set.prototype.intersection.call(new Set(this.values()), n);
  },
  union(n) {
    return Set.prototype.union.call(new Set(this.values()), n);
  },
  difference(n) {
    return Set.prototype.difference.call(new Set(this.values()), n);
  },
  symmetricDifference(n) {
    return Set.prototype.symmetricDifference.call(new Set(this.values()), n);
  },
  isSubsetOf(n) {
    return Set.prototype.isSubsetOf.call(new Set(this.values()), n);
  },
  isSupersetOf(n) {
    return Set.prototype.isSupersetOf.call(new Set(this.values()), n);
  },
  isDisjointFrom(n) {
    return Set.prototype.isDisjointFrom.call(new Set(this.values()), n);
  }
});
const ir = Reflect.ownKeys(ke), an = /* @__PURE__ */ new WeakSet(), cn = {
  get(n, e, t) {
    var r, s;
    const i = (r = n.copy) === null || r === void 0 ? void 0 : r[e];
    if (i && an.has(i))
      return i;
    if (e === nn)
      return n;
    let o;
    if (n.options.mark) {
      const u = e === "size" && (n.original instanceof Map || n.original instanceof Set) ? Reflect.get(n.original, e) : Reflect.get(n.original, e, t);
      if (o = n.options.mark(u, F), o === F.mutable)
        return n.options.strict && ve(u, n.options, !0), u;
    }
    const a = N(n);
    if (a instanceof Map && sr.includes(e)) {
      if (e === "size")
        return Object.getOwnPropertyDescriptor(Qe, "size").get.call(n.proxy);
      const u = Qe[e];
      if (u)
        return u.bind(n.proxy);
    }
    if (a instanceof Set && ir.includes(e)) {
      if (e === "size")
        return Object.getOwnPropertyDescriptor(ke, "size").get.call(n.proxy);
      const u = ke[e];
      if (u)
        return u.bind(n.proxy);
    }
    if (!le(a, e)) {
      const u = At(a, e);
      return u ? "value" in u ? u.value : (
        // !case: support for getter
        (s = u.get) === null || s === void 0 ? void 0 : s.call(n.proxy)
      ) : void 0;
    }
    const c = a[e];
    if (n.options.strict && ve(c, n.options), n.finalized || !z(c, n.options))
      return c;
    if (c === xe(n.original, e)) {
      if ($(n), n.copy[e] = dt({
        original: n.original[e],
        parentDraft: n,
        key: n.type === 1 ? Number(e) : e,
        finalities: n.finalities,
        options: n.options
      }), typeof o == "function") {
        const u = A(n.copy[e]);
        return $(u), Q(u), u.copy;
      }
      return n.copy[e];
    }
    return c;
  },
  set(n, e, t) {
    var r;
    if (n.type === 3 || n.type === 2)
      throw new Error("Map/Set draft does not support any property assignment.");
    let s;
    if (n.type === 1 && e !== "length" && !(Number.isInteger(s = Number(e)) && s >= 0 && (e === 0 || s === 0 || String(s) === String(e))))
      throw new Error("Only supports setting array indices and the 'length' property.");
    const i = At(N(n), e);
    if (i != null && i.set)
      return i.set.call(n.proxy, t), !0;
    const o = xe(N(n), e), a = A(o);
    return a && G(a.original, t) ? (n.copy[e] = t, n.assignedMap = (r = n.assignedMap) !== null && r !== void 0 ? r : /* @__PURE__ */ new Map(), n.assignedMap.set(e, !1), !0) : (G(t, o) && (t !== void 0 || le(n.original, e)) || ($(n), Q(n), le(n.original, e) && G(t, n.original[e]) ? n.assignedMap.delete(e) : n.assignedMap.set(e, !0), n.copy[e] = t, ft(n, e, t, he)), !0);
  },
  has(n, e) {
    return e in N(n);
  },
  ownKeys(n) {
    return Reflect.ownKeys(N(n));
  },
  getOwnPropertyDescriptor(n, e) {
    const t = N(n), r = Reflect.getOwnPropertyDescriptor(t, e);
    return r && {
      writable: !0,
      configurable: n.type !== 1 || e !== "length",
      enumerable: r.enumerable,
      value: t[e]
    };
  },
  getPrototypeOf(n) {
    return Reflect.getPrototypeOf(n.original);
  },
  setPrototypeOf() {
    throw new Error("Cannot call 'setPrototypeOf()' on drafts");
  },
  defineProperty() {
    throw new Error("Cannot call 'defineProperty()' on drafts");
  },
  deleteProperty(n, e) {
    var t;
    return n.type === 1 ? cn.set.call(this, n, e, void 0, n.proxy) : (xe(n.original, e) !== void 0 || e in n.original ? ($(n), Q(n), n.assignedMap.set(e, !1)) : (n.assignedMap = (t = n.assignedMap) !== null && t !== void 0 ? t : /* @__PURE__ */ new Map(), n.assignedMap.delete(e)), n.copy && delete n.copy[e], !0);
  }
};
function dt(n) {
  const { original: e, parentDraft: t, key: r, finalities: s, options: i } = n, o = Z(e), a = {
    type: o,
    finalized: !1,
    parent: t,
    original: e,
    copy: null,
    proxy: null,
    finalities: s,
    options: i,
    // Mapping of draft Set items to their corresponding draft values.
    setMap: o === 3 ? new Map(e.entries()) : void 0
  };
  (r || "key" in n) && (a.key = r);
  const { proxy: c, revoke: u } = Proxy.revocable(o === 1 ? Object.assign([], a) : a, cn);
  if (s.revoke.push(u), an.add(c), a.proxy = c, t) {
    const l = t;
    l.finalities.draft.push((f, d) => {
      var h, p;
      const b = A(c);
      let _ = l.type === 3 ? l.setMap : l.copy;
      const g = B(_, r), y = A(g);
      if (y) {
        let w = y.original;
        y.operated && (w = ut(g)), ze(y), Ve(y, he, f, d), l.options.enableAutoFreeze && (l.options.updatedValues = (h = l.options.updatedValues) !== null && h !== void 0 ? h : /* @__PURE__ */ new WeakMap(), l.options.updatedValues.set(w, y.original)), ye(_, r, w);
      }
      (p = b.callbacks) === null || p === void 0 || p.forEach((w) => {
        w(f, d);
      });
    });
  } else {
    const l = A(c);
    l.finalities.draft.push((f, d) => {
      ze(l), Ve(l, he, f, d);
    });
  }
  return c;
}
ot.createDraft = dt;
function or(n, e, t, r, s) {
  var i;
  const o = A(n), a = (i = o == null ? void 0 : o.original) !== null && i !== void 0 ? i : n, c = !!e.length;
  if (o != null && o.operated)
    for (; o.finalities.draft.length > 0; )
      o.finalities.draft.pop()(t, r);
  const u = c ? e[0] : o ? o.operated ? o.copy : o.original : n;
  return o && Ke(o), s && ee(u, u, o == null ? void 0 : o.options.updatedValues), [
    u,
    t && c ? [{ op: I.Replace, path: [], value: e[0] }] : t,
    r && c ? [{ op: I.Replace, path: [], value: a }] : r
  ];
}
function ar(n, e) {
  var t;
  const r = {
    draft: [],
    revoke: [],
    handledSet: /* @__PURE__ */ new WeakSet()
  };
  let s, i;
  e.enablePatches && (s = [], i = []);
  const a = ((t = e.mark) === null || t === void 0 ? void 0 : t.call(e, n, F)) === F.mutable || !z(n, e) ? n : dt({
    original: n,
    parentDraft: null,
    finalities: r,
    options: e
  });
  return [
    a,
    (c = []) => {
      const [u, l, f] = or(a, c, s, i, e.enableAutoFreeze);
      return e.enablePatches ? [u, l, f] : u;
    }
  ];
}
function We(n) {
  const { rootDraft: e, value: t, useRawReturn: r = !1, isRoot: s = !0 } = n;
  lt(t, (i, o, a) => {
    const c = A(o);
    if (c && e && c.finalities === e.finalities) {
      n.isContainDraft = !0;
      const u = c.original;
      if (a instanceof Set) {
        const l = Array.from(a);
        a.clear(), l.forEach((f) => a.add(i === f ? u : f));
      } else
        ye(a, i, u);
    } else typeof o == "object" && o !== null && (n.value = o, n.isRoot = !1, We(n));
  }), s && (n.isContainDraft || console.warn("The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance."), r && console.warn("The return value contains drafts, please don't use 'rawReturn()' to wrap the return value."));
}
function un(n) {
  var e;
  const t = A(n);
  if (!z(n, t == null ? void 0 : t.options))
    return n;
  const r = Z(n);
  if (t && !t.operated)
    return t.original;
  let s;
  function i() {
    s = r === 2 ? ct(n) ? new Map(n) : new (Object.getPrototypeOf(n)).constructor(n) : r === 3 ? Array.from(t.setMap.values()) : sn(n, t == null ? void 0 : t.options);
  }
  if (t) {
    t.finalized = !0;
    try {
      i();
    } finally {
      t.finalized = !1;
    }
  } else
    s = n;
  if (lt(s, (o, a) => {
    if (t && G(B(t.original, o), a))
      return;
    const c = un(a);
    c !== a && (s === n && i(), ye(s, o, c));
  }), r === 3) {
    const o = (e = t == null ? void 0 : t.original) !== null && e !== void 0 ? e : s;
    return at(o) ? new Set(s) : new (Object.getPrototypeOf(o)).constructor(s);
  }
  return s;
}
function kt(n) {
  if (!Y(n))
    throw new Error(`current() is only used for Draft, parameter: ${n}`);
  return un(n);
}
const cr = (n) => function e(t, r, s) {
  var i, o, a;
  if (typeof t == "function" && typeof r != "function")
    return function(m, ...v) {
      return e(m, (O) => t.call(this, O, ...v), r);
    };
  const c = t, u = r;
  let l = s;
  if (typeof r != "function" && (l = r), l !== void 0 && Object.prototype.toString.call(l) !== "[object Object]")
    throw new Error(`Invalid options: ${l}, 'options' should be an object.`);
  l = Object.assign(Object.assign({}, n), l);
  const f = Y(c) ? kt(c) : c, d = Array.isArray(l.mark) ? (m, v) => {
    for (const O of l.mark) {
      if (typeof O != "function")
        throw new Error(`Invalid mark: ${O}, 'mark' should be a function.`);
      const L = O(m, v);
      if (L)
        return L;
    }
  } : l.mark, h = (i = l.enablePatches) !== null && i !== void 0 ? i : !1, p = (o = l.strict) !== null && o !== void 0 ? o : !1, _ = {
    enableAutoFreeze: (a = l.enableAutoFreeze) !== null && a !== void 0 ? a : !1,
    mark: d,
    strict: p,
    enablePatches: h
  };
  if (!z(f, _) && typeof f == "object" && f !== null)
    throw new Error("Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.");
  const [g, y] = ar(f, _);
  if (typeof r != "function") {
    if (!z(f, _))
      throw new Error("Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.");
    return [g, y];
  }
  let w;
  try {
    w = u(g);
  } catch (m) {
    throw Ke(A(g)), m;
  }
  const S = (m) => {
    const v = A(g);
    if (!Y(m)) {
      if (m !== void 0 && !G(m, g) && (v != null && v.operated))
        throw new Error("Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.");
      const L = m == null ? void 0 : m[Jn];
      if (L) {
        const Re = L[0];
        return _.strict && typeof m == "object" && m !== null && We({
          rootDraft: v,
          value: m,
          useRawReturn: !0
        }), y([Re]);
      }
      if (m !== void 0)
        return typeof m == "object" && m !== null && We({ rootDraft: v, value: m }), y([m]);
    }
    if (m === g || m === void 0)
      return y([]);
    const O = A(m);
    if (_ === O.options) {
      if (O.operated)
        throw new Error("Cannot return a modified child draft.");
      return y([kt(m)]);
    }
    return y([m]);
  };
  return w instanceof Promise ? w.then(S, (m) => {
    throw Ke(A(g)), m;
  }) : S(w);
}, Ee = cr();
Object.prototype.constructor.toString();
function ln(n, e) {
  const t = Object.keys(n), r = Object.keys(e);
  return t.length === r.length && Object.keys(n).every((s) => e.hasOwnProperty(s));
}
function Et(n, e) {
  return Object.keys(n).length === Object.keys(e).length && Object.keys(n).every(
    (t) => e.hasOwnProperty(t) && n[t] === e[t]
  );
}
function Oe(n, e) {
  return typeof n != "object" || typeof e != "object" || n === null || e === null ? n === e : ln(n, e) ? Object.keys(n).every(
    (t) => Oe(n[t], e[t])
  ) : !1;
}
function ht(n) {
  if (!ce(n))
    return n;
  const e = {};
  for (const [t, r] of Object.entries(n))
    r !== void 0 && (e[t] = r);
  return e;
}
function fn(n, e) {
  if (!ce(n) || !ce(e))
    return e;
  const t = { ...n };
  for (const r of Object.keys(e)) {
    if (e[r] === void 0) continue;
    if (e[r] === null) {
      delete t[r];
      continue;
    }
    const s = ce(n[r]) && ce(e[r]);
    t[r] = s ? fn(n[r], e[r]) : e[r];
  }
  return t;
}
function ce(n) {
  return typeof n == "object" && n !== null && !Array.isArray(n);
}
function ur(n, e, t) {
  if (!n || e.length === 0)
    return;
  let r = n || {};
  for (let i = 0; i < e.length - 1; i++) {
    const o = e[i];
    (!(o in r) || typeof r[o] != "object") && (r[o] = typeof e[i + 1] == "number" ? [] : {}), r = r[o];
  }
  const s = e[e.length - 1];
  Array.isArray(r) && typeof s == "number" ? r.splice(s, 0, t) : r[s] = t;
}
function It(n, e, t) {
  if (!n || e.length === 0)
    return;
  let r = n || {};
  for (let s = 0; s < e.length - 1; s++) {
    const i = e[s];
    (!(i in r) || typeof r[i] != "object") && (r[i] = typeof e[s + 1] == "number" ? [] : {}), r = r[i];
  }
  r[e[e.length - 1]] = t;
}
function dn(n, e) {
  if (!n || e.length === 0)
    return;
  const [t, ...r] = e;
  if (t in n) {
    if (r.length === 0) {
      Array.isArray(n) ? n.splice(t, 1) : delete n[t];
      return;
    }
    dn(n[t], r), lr(n[t]) && delete n[t];
  }
}
function lr(n) {
  return n && Object.keys(n).length === 0;
}
const Ct = /ZULU|YEKT|YEKST|YAPT|YAKT|YAKST|XJT|WGT|WGST|WFT|WETDST|WET|WDT|WAT|WAST|WAKT|WADT|VUT|VOLT|VLAT|VLAST|VET|UZT|UZST|UYT|UYST|UTC|UT|ULAT|ULAST|UCT|TVT|TRUT|TOT|TMT|TKT|TJT|TFT|TAHT|SGT|SCT|SAST|SADT|RET|PYT|PYST|PWT|PST|PONT|PMST|PMDT|PKT|PKST|PHT|PGT|PETT|PETST|PET|PDT|OMST|OMSST|NZT|NZST|NZDT|NUT|NST|NPT|NOVT|NOVST|NFT|NDT|MYT|MVT|MUT|MUST|MST|MSK|MSD|MPT|MMT|MHT|MEZ|METDST|MET|MESZ|MEST|MDT|MAWT|MART|MAGT|MAGST|LKT|LINT|LIGT|LHST|LHDT|KST|KRAT|KRAST|KOST|KGT|KGST|KDT|JST|JAYT|IST|IRT|IRKT|IRKST|IOT|IDT|ICT|HST|HKT|GYT|GMT|GILT|GFT|GET|GEST|GAMT|GALT|FNT|FNST|FKT|FKST|FJT|FJST|FET|EST|EGT|EGST|EETDST|EET|EEST|EDT|EAT|EAST|EASST|DDUT|DAVT|CXT|CST|COT|CLT|CLST|CKT|CHUT|CHAST|CHADT|CETDST|CET|CEST|CDT|CCT|CAST|CADT|BTT|BST|BRT|BRST|BRA|BOT|BORT|BNT|BDT|BDST|AZT|AZST|AZOT|AZOST|AWST|AWSST|AST|ART|ARST|ANAT|ANAST|AMT|AMST|ALMT|ALMST|AKST|AKDT|AFT|AEST|AESST|AEDT|ADT|ACWST|ACT|ACST|ACSST|ACDT$/, fr = {
  ZULU: 0,
  YEKT: 18e3,
  YEKST: 21600,
  YAPT: 36e3,
  YAKT: 32400,
  YAKST: 32400,
  XJT: 21600,
  WGT: -10800,
  WGST: -7200,
  WFT: 43200,
  WETDST: 3600,
  WET: 0,
  WDT: 32400,
  WAT: 3600,
  WAST: 25200,
  WAKT: 43200,
  WADT: 28800,
  VUT: 39600,
  VOLT: 10800,
  VLAT: 36e3,
  VLAST: 36e3,
  VET: -14400,
  UZT: 18e3,
  UZST: 21600,
  UYT: -10800,
  UYST: -7200,
  UTC: 0,
  UT: 0,
  ULAT: 28800,
  ULAST: 32400,
  UCT: 0,
  TVT: 43200,
  TRUT: 36e3,
  TOT: 46800,
  TMT: 18e3,
  TKT: 46800,
  TJT: 18e3,
  TFT: 18e3,
  TAHT: -36e3,
  SGT: 28800,
  SCT: 14400,
  SAST: 7200,
  SADT: 37800,
  RET: 14400,
  PYT: -14400,
  PYST: -10800,
  PWT: 32400,
  PST: -28800,
  PONT: 39600,
  PMST: -10800,
  PMDT: -7200,
  PKT: 18e3,
  PKST: 21600,
  PHT: 28800,
  PGT: 36e3,
  PETT: 43200,
  PETST: 43200,
  PET: -18e3,
  PDT: -25200,
  OMST: 21600,
  OMSST: 21600,
  NZT: 43200,
  NZST: 43200,
  NZDT: 46800,
  NUT: -39600,
  NST: -12600,
  NPT: 20700,
  NOVT: 25200,
  NOVST: 25200,
  NFT: -12600,
  NDT: -9e3,
  MYT: 28800,
  MVT: 18e3,
  MUT: 14400,
  MUST: 18e3,
  MST: -25200,
  MSK: 10800,
  MSD: 14400,
  MPT: 36e3,
  MMT: 23400,
  MHT: 43200,
  MEZ: 3600,
  METDST: 7200,
  MET: 3600,
  MESZ: 7200,
  MEST: 7200,
  MDT: -21600,
  MAWT: 18e3,
  MART: -34200,
  MAGT: 39600,
  MAGST: 39600,
  LKT: 19800,
  LINT: 50400,
  LIGT: 36e3,
  LHST: 37800,
  LHDT: 37800,
  KST: 32400,
  KRAT: 25200,
  KRAST: 25200,
  KOST: 39600,
  KGT: 21600,
  KGST: 21600,
  KDT: 36e3,
  JST: 32400,
  JAYT: 32400,
  IST: 7200,
  IRT: 12600,
  IRKT: 28800,
  IRKST: 28800,
  IOT: 21600,
  IDT: 10800,
  ICT: 25200,
  HST: -36e3,
  HKT: 28800,
  GYT: -14400,
  GMT: 0,
  GILT: 43200,
  GFT: -10800,
  GET: 14400,
  GEST: 14400,
  GAMT: -32400,
  GALT: -21600,
  FNT: -7200,
  FNST: -3600,
  FKT: -10800,
  FKST: -10800,
  FJT: 43200,
  FJST: 46800,
  FET: 10800,
  EST: -18e3,
  EGT: -3600,
  EGST: 0,
  EETDST: 10800,
  EET: 7200,
  EEST: 10800,
  EDT: -14400,
  EAT: 10800,
  EAST: -21600,
  EASST: -21600,
  DDUT: 36e3,
  DAVT: 25200,
  CXT: 25200,
  CST: -21600,
  COT: -18e3,
  CLT: -14400,
  CLST: -10800,
  CKT: -36e3,
  CHUT: 36e3,
  CHAST: 45900,
  CHADT: 49500,
  CETDST: 7200,
  CET: 3600,
  CEST: 7200,
  CDT: -18e3,
  CCT: 28800,
  CAST: 34200,
  CADT: 37800,
  BTT: 21600,
  BST: 3600,
  BRT: -10800,
  BRST: -7200,
  BRA: -10800,
  BOT: -14400,
  BORT: 28800,
  BNT: 28800,
  BDT: 21600,
  BDST: 7200,
  AZT: 14400,
  AZST: 14400,
  AZOT: -3600,
  AZOST: 0,
  AWST: 28800,
  AWSST: 32400,
  AST: -14400,
  ART: -10800,
  ARST: -10800,
  ANAT: 43200,
  ANAST: 43200,
  AMT: -14400,
  AMST: 14400,
  ALMT: 21600,
  ALMST: 25200,
  AKST: -32400,
  AKDT: -28800,
  AFT: 16200,
  AEST: 36e3,
  AESST: 39600,
  AEDT: 39600,
  ADT: -10800,
  ACWST: 31500,
  ACT: -18e3,
  ACST: 34200,
  ACSST: 37800,
  ACDT: 37800
};
function dr(n) {
  return new Date(n);
}
function hr(n) {
  return /* @__PURE__ */ new Date(n + "Z");
}
const pr = /^(\d+)[\./-](\d+)[\./-](\d+)$/;
function yr(n) {
  const e = n.match(pr);
  if (!e)
    return null;
  const [t, r, s, i] = e;
  return r <= 0 || s <= 0 || i <= 0 ? null : r > 999 ? new Date(Date.UTC(r, s - 1, i, 0, 0, 0, 0)) : new Date(Date.UTC(i, r - 1, s, 0, 0, 0, 0));
}
function br(n) {
  const [e, t] = n.split(" ");
  return /* @__PURE__ */ new Date(e + "T" + t + "Z");
}
function gr(n) {
  const [e, t] = n.split(" ");
  return /* @__PURE__ */ new Date(e + "T" + t + "Z");
}
function _r(n) {
  return new Date(n);
}
function wr(n) {
  const e = /^(\w{3}) (\w{3}) (\d{2}) (\d{4})$/;
  if (!n.match(e))
    throw new Error(`Unable to parse \`${n}\` as a date.`);
  const r = /* @__PURE__ */ new Date(n + " UTC");
  return new Date(
    Date.UTC(
      r.getUTCFullYear(),
      r.getUTCMonth(),
      r.getUTCDate(),
      0,
      0,
      0,
      0
    )
  );
}
function Tr(n) {
  const e = /^(.+T.+)([+-])(\d{2})$/, t = n.match(e);
  if (t) {
    const [, r, s, i] = t, o = `${r}${s}${i}:00`;
    return new Date(o);
  }
  return null;
}
function mr(n) {
  const e = /^(\d+)-(\d{1,2})-(\d{1,2})([ T])(.+)$/, t = n.match(e);
  if (t) {
    const [, r, s, i, o, a] = t, c = s.padStart(2, "0"), u = i.padStart(2, "0"), l = `${r}-${c}-${u}T${a}`;
    return new Date(l);
  }
  return null;
}
function Sr(n) {
  const [e, t] = n.split(", "), [r, s, i] = e.split("/").map(Number), o = t.match(/(\d{1,2}):(\d{2}):(\d{2}) (AM|PM)/);
  if (!o)
    throw new Error(`Unable to parse time from: ${n}`);
  let [, a, c, u, l] = o;
  return a = Number(a), c = Number(c), u = Number(u), l === "PM" && a !== 12 ? a += 12 : l === "AM" && a === 12 && (a = 0), new Date(Date.UTC(i, r - 1, s, a, c, u));
}
function Ar(n) {
  switch (n) {
    case "epoch":
      return /* @__PURE__ */ new Date(0);
    case "infinity":
    case "-infinity":
    case "today":
    case "tomorrow":
    case "yesterday":
      return null;
  }
}
function Or(n) {
  const e = n.match(Ct);
  if (!e)
    return null;
  const [t] = e, r = fr[t], s = new Date(n.replace(Ct, "Z"));
  return new Date(s.getTime() - r * 1e3);
}
const vr = [
  yr,
  gr,
  wr,
  Sr,
  _r,
  hr,
  Tr,
  br,
  dr,
  Ar,
  Or,
  mr
];
function kr(n, e) {
  try {
    const t = n(e);
    return t instanceof Date && !isNaN(t.getTime()) ? t : null;
  } catch {
    return null;
  }
}
function Ge(n) {
  for (const e of vr) {
    const t = kr(e, n);
    if (t)
      return t;
  }
  return null;
}
function Er(n) {
  try {
    const e = JSON.parse(n);
    return typeof e == "string" ? Ge(e) : null;
  } catch {
    return null;
  }
}
function Me(n) {
  if (n !== void 0) {
    if (n === null)
      return null;
    if (n instanceof Date)
      return n;
    if (typeof n == "string") {
      const e = Ge(n) || Er(n) || Ge(n.trim());
      if (!e)
        throw new Error(`Unable to parse \`${n}\` as a date.`);
      return e;
    } else if (typeof n == "number")
      return new Date(n);
    throw new Error(
      `Invalid date value \`${n}\`. Expected a date, number, or string, got type ${typeof n}.`
    );
  }
}
class H {
  constructor(e, t) {
    this._blobAttrs = null, this._primaryKeys = null, this._forwardIdents = null, this._revIdents = null, this.attrs = e, this.linkIndex = t;
  }
  resetAttrIndexes() {
    this._blobAttrs = null, this._primaryKeys = null, this._forwardIdents = null, this._revIdents = null;
  }
  addAttr(e) {
    this.attrs[e.id] = e, this.resetAttrIndexes();
  }
  deleteAttr(e) {
    delete this.attrs[e], this.resetAttrIndexes();
  }
  updateAttr(e) {
    const t = this.attrs[e.id];
    t && (this.attrs[e.id] = { ...t, ...e }, this.resetAttrIndexes());
  }
  getAttr(e) {
    return this.attrs[e];
  }
  get blobAttrs() {
    if (this._blobAttrs)
      return this._blobAttrs;
    this._blobAttrs = /* @__PURE__ */ new Map();
    for (const e of Object.values(this.attrs))
      if (yt(e)) {
        const [t, r, s] = e["forward-identity"];
        R(this.blobAttrs, [r, s], e);
      }
    return this._blobAttrs;
  }
  get primaryKeys() {
    if (this._primaryKeys)
      return this._primaryKeys;
    this._primaryKeys = /* @__PURE__ */ new Map();
    for (const e of Object.values(this.attrs))
      if (e["primary?"]) {
        const [t, r] = e["forward-identity"];
        R(this._primaryKeys, [r], e);
      }
    return this._primaryKeys;
  }
  get forwardIdents() {
    if (this._forwardIdents)
      return this._forwardIdents;
    this._forwardIdents = /* @__PURE__ */ new Map();
    for (const e of Object.values(this.attrs)) {
      const t = e["forward-identity"], [r, s, i] = t;
      R(this._forwardIdents, [s, i], e);
    }
    return this._forwardIdents;
  }
  get revIdents() {
    if (this._revIdents)
      return this._revIdents;
    this._revIdents = /* @__PURE__ */ new Map();
    for (const e of Object.values(this.attrs)) {
      const t = e["reverse-identity"];
      if (t) {
        const [r, s, i] = t;
        R(this._revIdents, [s, i], e);
      }
    }
    return this._revIdents;
  }
  toJSON() {
    return { attrs: this.attrs, linkIndex: this.linkIndex };
  }
}
function Ir(n) {
  return n.cardinality === "one";
}
function pt(n) {
  return n["value-type"] === "ref";
}
function yt(n) {
  return n["value-type"] === "blob";
}
function ie(n, e) {
  return e.reduce((t, r) => t && t.get(r), n);
}
function K(n, e) {
  if (e.length === 0) throw new Error("path must have at least one element");
  if (e.length === 1) {
    n.delete(e[0]);
    return;
  }
  const [t, ...r] = e;
  n.has(t) && K(n.get(t), r);
}
function R(n, e, t) {
  let r = n;
  const s = e.length - 1;
  for (let i = 0; i < s; i++) {
    const o = e[i];
    let a = r.get(o);
    a === void 0 && (a = /* @__PURE__ */ new Map(), r.set(o, a)), r = a;
  }
  s > -1 && r.set(e[s], t);
}
function hn(n, e, t) {
  const r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  for (const o of e) {
    let [a, c, u] = o;
    const l = n.getAttr(c);
    if (!l) {
      console.warn("no such attr", c, a);
      continue;
    }
    l["checked-data-type"] === "date" && t && (u = Me(u), o[2] = u), pt(l) && R(i, [u, c, a], o), R(r, [a, c, u], o), R(s, [c, a, u], o);
  }
  return { eav: r, aev: s, vae: i };
}
function pn(n) {
  return {
    triples: x(n.eav, 3),
    cardinalityInference: n.cardinalityInference,
    useDateObjects: n.useDateObjects,
    version: 1
  };
}
function yn(n, e) {
  return te(
    n,
    e.triples,
    e.cardinalityInference,
    e.useDateObjects
  );
}
function bn(n, e) {
  if (n)
    return new H(n.attrs, n.linkIndex);
  if (e && "__type" in e)
    return new H(e.attrs, e.linkIndex);
}
function Cr(n, e) {
  return ie(n.eav, [e]) !== void 0;
}
function te(n, e, t, r) {
  const s = hn(
    n,
    e,
    r
  );
  return s.cardinalityInference = t, s.useDateObjects = r, s;
}
function be(n, e) {
  var s, i;
  let t;
  if (Array.isArray(e[0])) {
    const [o, a] = e[0], c = n.aev.get(o);
    if (!c)
      return null;
    t = (s = x(c, 2).find((l) => l[2] === a)) == null ? void 0 : s[0];
  } else
    t = e[0];
  if (!t)
    return null;
  const r = e[2];
  if (Array.isArray(r) && r.length === 2 && n.aev.get(r[0])) {
    const [o, a] = r, c = n.aev.get(o);
    if (!c)
      return null;
    const l = (i = x(c, 2).find((b) => b[2] === a)) == null ? void 0 : i[0];
    if (!l)
      return null;
    const [f, d, h, ...p] = e;
    return [t, d, l, ...p];
  } else {
    const [o, ...a] = e;
    return [t, ...a];
  }
}
function gn(n, e, t) {
  const r = be(n, t);
  if (!r)
    return;
  const [s, i, o] = r, a = e.getAttr(i);
  a && (K(n.eav, [s, i, o]), K(n.aev, [i, s, o]), pt(a) && K(n.vae, [o, i, s]));
}
let Mr = 0;
function _n(n, e, t) {
  const [r, s, i] = t;
  let o;
  const a = ie(n.eav, [r, s, i]);
  return a && (o = a[3]), o || Date.now() * 10 + Mr++;
}
function wn(n, e, t) {
  const r = be(n, t);
  if (!r)
    return;
  let [s, i, o] = r;
  const a = e.getAttr(i);
  if (!a)
    return;
  a["checked-data-type"] === "date" && n.useDateObjects && (o = Me(o));
  const c = ie(n.eav, [s, i, o]), u = (c == null ? void 0 : c[3]) ?? _n(n, a, r), l = [s, i, o, u];
  Ir(a) ? (R(n.eav, [s, i], /* @__PURE__ */ new Map([[o, l]])), R(n.aev, [i, s], /* @__PURE__ */ new Map([[o, l]]))) : (R(n.eav, [s, i, o], l), R(n.aev, [i, s, o], l)), pt(a) && R(n.vae, [o, i, s], l);
}
function Pr(n, e, t) {
  var h;
  const r = be(n, t);
  if (!r)
    return;
  const [s, i, o] = r, a = e.getAttr(i);
  if (!a) return;
  if (!yt(a))
    throw new Error("merge operation is not supported for links");
  const c = ie(n.eav, [s, i]);
  if (!c) return;
  const u = (h = c.values().next()) == null ? void 0 : h.value;
  if (!u) return;
  const l = u[2], f = fn(l, o), d = [
    s,
    i,
    f,
    _n(n, a, u)
  ];
  R(n.eav, [s, i], /* @__PURE__ */ new Map([[f, d]])), R(n.aev, [i, s], /* @__PURE__ */ new Map([[f, d]]));
}
function Be(n, e, t) {
  var u, l;
  const [r, s] = t, i = be(n, [r]);
  if (!i)
    return;
  const [o] = i, a = n.eav.get(o);
  if (a) {
    for (const f of a.keys()) {
      const d = e.getAttr(f);
      d && d["on-delete-reverse"] === "cascade" && x(a.get(f), 1).forEach(
        ([h, p, b]) => {
          var _;
          return Be(n, e, [b, (_ = d["reverse-identity"]) == null ? void 0 : _[1]]);
        }
      ), // Fall back to deleting everything if we've rehydrated tx-steps from
      // the store that didn't set `etype` in deleteEntity
      (!s || // If we don't know about the attr, let's just get rid of it
      !d || // Make sure it matches the etype
      ((u = d["forward-identity"]) == null ? void 0 : u[1]) === s) && (K(n.aev, [f, o]), K(n.eav, [o, f]));
    }
    a.size === 0 && K(n.eav, [o]);
  }
  const c = n.vae.get(o) && x(n.vae.get(o), 2);
  c && c.forEach((f) => {
    var _, g, y;
    const [d, h, p] = f, b = e.getAttr(h);
    (!s || !b || ((_ = b["reverse-identity"]) == null ? void 0 : _[1]) === s) && (K(n.eav, [d, h, p]), K(n.aev, [h, d, p]), K(n.vae, [p, h, d])), b && b["on-delete"] === "cascade" && ((g = b["reverse-identity"]) == null ? void 0 : g[1]) === s && Be(n, e, [d, (y = b["forward-identity"]) == null ? void 0 : y[1]]);
  }), ((l = n.vae.get(o)) == null ? void 0 : l.size) === 0 && K(n.vae, [o]);
}
function Tn(n, e, t) {
  const r = hn(
    e,
    t,
    n.useDateObjects
  );
  Object.keys(r).forEach((s) => {
    n[s] = r[s];
  });
}
function jr(n, [e]) {
  n.addAttr(e);
}
function mn(n) {
  return x(n.eav, 3);
}
function $r(n, e, [t]) {
  if (!e.getAttr(t)) return;
  const r = mn(n).filter(([s, i]) => i !== t);
  e.deleteAttr(t), Tn(n, e, r);
}
function Dr(n, e, [t]) {
  e.getAttr(t.id) && (e.updateAttr(t), Tn(n, e, mn(n)));
}
function Rr(n, e, t) {
  const [r, ...s] = t;
  switch (r) {
    case "add-triple":
      wn(n, e, s);
      break;
    case "deep-merge-triple":
      Pr(n, e, s);
      break;
    case "retract-triple":
      gn(n, e, s);
      break;
    case "delete-entity":
      Be(n, e, s);
      break;
    case "add-attr":
      jr(e, s);
      break;
    case "delete-attr":
      $r(n, e, s);
      break;
    case "update-attr":
      Dr(n, e, s);
      break;
    case "restore-attr":
      break;
    case "rule-params":
      break;
    default:
      throw new Error(`unhandled transaction action: ${r}`);
  }
}
function x(n, e, t = []) {
  if (!n || e === 0)
    return t;
  if (e === 1) {
    for (const r of n.values())
      t.push(r);
    return t;
  }
  for (const r of n.values())
    x(r, e - 1, t);
  return t;
}
function ge(n, e, t) {
  var i;
  const r = [];
  if (t != null && t.hasOwnProperty("$not")) {
    for (const o of e.keys())
      t.$not !== o && r.push(e.get(o));
    return r;
  }
  if (t != null && t.hasOwnProperty("$isNull")) {
    const { attrId: o, isNull: a, reverse: c } = t.$isNull;
    if (c)
      for (const u of e.keys()) {
        const l = n.vae.get(u), f = !l || !l.get(o);
        (a ? f : !f) && r.push(e.get(u));
      }
    else {
      const u = n.aev.get(o);
      for (const l of e.keys()) {
        const f = !u || ((i = u.get(l)) == null ? void 0 : i.get(null)) || !u.get(l);
        (a ? f : !f) && r.push(e.get(l));
      }
    }
    return r;
  }
  if (t != null && t.$comparator)
    return x(e, 1).filter(t.$op);
  const s = t.in || t.$in || [t];
  for (const o of s) {
    const a = e.get(o);
    a && r.push(a);
  }
  return r;
}
function xr(n, e, t) {
  let r = "";
  return n !== void 0 && (r += "e"), e !== void 0 && (r += "a"), t !== void 0 && (r += "v"), r;
}
function Ur(n, [e, t, r]) {
  var i, o;
  switch (xr(e, t, r)) {
    case "e": {
      const a = n.eav.get(e);
      return x(a, 2);
    }
    case "ea": {
      const a = (i = n.eav.get(e)) == null ? void 0 : i.get(t);
      return x(a, 1);
    }
    case "eav": {
      const a = (o = n.eav.get(e)) == null ? void 0 : o.get(t);
      return a ? ge(n, a, r) : [];
    }
    case "ev": {
      const a = n.eav.get(e);
      if (!a)
        return [];
      const c = [];
      for (const u of a.values())
        c.push(...ge(n, u, r));
      return c;
    }
    case "a": {
      const a = n.aev.get(t);
      return x(a, 2);
    }
    case "av": {
      const a = n.aev.get(t);
      if (!a)
        return [];
      const c = [];
      for (const u of a.values())
        c.push(...ge(n, u, r));
      return c;
    }
    case "v": {
      const a = [];
      for (const c of n.eav.values())
        for (const u of c.values())
          a.push(...ge(n, u, r));
      return a;
    }
    default:
      return x(n.eav, 3);
  }
}
function Lr(n, e, t) {
  var s;
  const r = {};
  if (!e)
    return r;
  for (const [i, o] of e.entries()) {
    const a = (s = n.eav.get(t)) == null ? void 0 : s.get(o.id), c = x(a, 1);
    for (const u of c)
      r[i] = u[2];
  }
  return r;
}
function C(n, e, t) {
  var r;
  return (r = n.forwardIdents.get(e)) == null ? void 0 : r.get(t);
}
function X(n, e, t) {
  var r;
  return (r = n.revIdents.get(e)) == null ? void 0 : r.get(t);
}
function Nr(n, e) {
  return n.blobAttrs.get(e);
}
function Sn(n, e) {
  var r;
  const t = n.primaryKeys.get(e);
  return t || ((r = n.forwardIdents.get(e)) == null ? void 0 : r.get("id"));
}
function Fr(n, e, t) {
  const r = be(n, t);
  if (!r)
    return;
  const [s, i, o] = r;
  if (e.getAttr(i))
    return ie(n.eav, [s, i]);
}
function qr(n, e, t) {
  const r = t.filter(
    ([s, i, o, a, c]) => {
      if (s !== "add-triple" && s !== "deep-merge-triple")
        return !0;
      const u = c == null ? void 0 : c.mode;
      if (u !== "create" && u !== "update")
        return !0;
      let l = !1;
      const f = e.getAttr(o);
      if (f) {
        const d = Sn(
          e,
          f["forward-identity"][1]
        );
        l = !!Fr(n, e, [
          i,
          d == null ? void 0 : d.id,
          i
        ]);
      }
      return !(u === "create" && l || u === "update" && !l);
    }
  );
  return Ee(
    { store: n, attrsStore: e },
    (s) => {
      r.forEach((i) => {
        Rr(s.store, s.attrsStore, i);
      });
    },
    {
      mark: (s) => {
        if (s instanceof H)
          return "immutable";
      }
    }
  );
}
function Kr(n) {
  return typeof n == "string" && n.startsWith("?");
}
function zr(n, e, t) {
  if (t.hasOwnProperty(n)) {
    const r = t[n];
    return An(r, e, t);
  }
  return { ...t, [n]: e };
}
function Mt(n, e, t) {
  return n === e ? t : null;
}
function Vr(n) {
  switch (typeof n) {
    case "string":
      return n.startsWith("?") ? zr : Mt;
    default:
      return Mt;
  }
}
const Qr = [
  "in",
  "$in",
  "$not",
  "$isNull",
  "$comparator"
  // covers all of $gt, $lt, etc.
];
function Wr(n) {
  for (const e of Qr)
    if (n.hasOwnProperty(e))
      return !0;
  return !1;
}
function An(n, e, t) {
  return t ? typeof n == "object" ? Wr(n) ? t : null : Vr(n)(n, e, t) : null;
}
function Gr(n, e, t) {
  return n.reduce((r, s, i) => {
    const o = e[i];
    return An(s, o, r);
  }, t);
}
function Br(n, e, t) {
  return Yr(n, e, t).map((r) => Gr(e, r, t)).filter((r) => r);
}
function Hr(n, e, t) {
  return e.or ? e.or.patterns.flatMap((r) => He(n, r, t)) : e.and ? e.and.patterns.reduce((r, s) => He(n, s, r), t) : t.flatMap((r) => Br(n, e, r));
}
function He(n, e, t = [{}]) {
  return e.reduce((r, s) => Hr(n, s, r), t);
}
function bt(n, e) {
  return Array.isArray(e) ? e.map((t) => bt(n, t)) : Kr(e) ? n[e] : e;
}
function Jr(n, { find: e, where: t }) {
  return He(n, t).map((s) => bt(s, e));
}
function Yr(n, e, t) {
  return Ur(n, bt(t, e));
}
const Zr = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
function re(n) {
  return typeof n == "string" && Zr.test(n);
}
const j = [];
for (let n = 0; n < 256; ++n)
  j.push((n + 256).toString(16).slice(1));
function Xr(n, e = 0) {
  return (j[n[e + 0]] + j[n[e + 1]] + j[n[e + 2]] + j[n[e + 3]] + "-" + j[n[e + 4]] + j[n[e + 5]] + "-" + j[n[e + 6]] + j[n[e + 7]] + "-" + j[n[e + 8]] + j[n[e + 9]] + "-" + j[n[e + 10]] + j[n[e + 11]] + j[n[e + 12]] + j[n[e + 13]] + j[n[e + 14]] + j[n[e + 15]]).toLowerCase();
}
let Ue;
const es = new Uint8Array(16);
function ts() {
  if (!Ue) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Ue = crypto.getRandomValues.bind(crypto);
  }
  return Ue(es);
}
const ns = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Pt = { randomUUID: ns };
function rs(n, e, t) {
  var s;
  if (Pt.randomUUID && !n)
    return Pt.randomUUID();
  n = n || {};
  const r = n.random ?? ((s = n.rng) == null ? void 0 : s.call(n)) ?? ts();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, Xr(r);
}
function jt(n) {
  const e = n.replace(/-/g, ""), t = [];
  for (let r = 0; r < e.length; r += 2)
    t.push(parseInt(e.substring(r, r + 2), 16));
  return t;
}
function ss(n, e) {
  for (let t = 0; t < n.length; t++) {
    if (n[t] < e[t]) return -1;
    if (n[t] > e[t]) return 1;
  }
  return 0;
}
function is(n, e) {
  return ss(jt(n), jt(e));
}
function P() {
  return rs();
}
function os(n, e) {
  return n.localeCompare(e);
}
function as() {
  let n = os;
  if (typeof Intl == "object" && Intl.hasOwnProperty("Collator"))
    try {
      n = Intl.Collator("en-US").compare;
    } catch {
    }
  return n;
}
const cs = as();
let us = 0;
function fe(n) {
  return Pe(`_${n}`, us++);
}
function Pe(n, e) {
  return `?${n}-${e}`;
}
class se extends Error {
  constructor(e) {
    super(e), this.name = "AttrNotFoundError";
  }
}
function ls(n, e) {
  const t = Sn(n, e);
  if (!t)
    throw new se(`Could not find id attr for ${e}`);
  return t;
}
function $t(n, e, t, r) {
  return [fs(n, e, t, r)];
}
function fs(n, e, t, r) {
  return [
    n(t, r),
    ls(e, t).id,
    n(t, r),
    n("time", r)
  ];
}
function ds(n, e, t) {
  return n.map((r) => r === e ? t : r);
}
function On(n, e, t, r, s) {
  const i = C(e, t, s), o = X(e, t, s), a = i || o;
  if (!a)
    throw new se(`Could not find attr for ${[t, s]}`);
  if (a["value-type"] !== "ref")
    throw new Error(`Attr ${a.id} is not a ref`);
  const [c, u] = a["forward-identity"], [l, f] = a["reverse-identity"], d = r + 1, h = i ? [
    n(u, r),
    a.id,
    n(f, d),
    fe("time")
  ] : [
    n(u, d),
    a.id,
    n(f, r),
    fe("time")
  ];
  return [i ? f : u, d, h, a, !!i];
}
function Dt(n, e) {
  if (typeof e != "string")
    return function(o) {
      return !1;
    };
  const r = e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/%/g, ".*").replace(/_/g, "."), s = new RegExp(
    `^${r}$`,
    n ? void 0 : "i"
  );
  return function(o) {
    return typeof o != "string" ? !1 : s.test(o);
  };
}
function hs(n, e) {
  if (typeof e != "object" || e.hasOwnProperty("$in") || e.hasOwnProperty("in"))
    return e;
  const t = n["checked-data-type"] === "date";
  if (e.hasOwnProperty("$gt"))
    return {
      $comparator: !0,
      $op: t ? function(s) {
        return new Date(s[2]) > new Date(e.$gt);
      } : function(s) {
        return s[2] > e.$gt;
      }
    };
  if (e.hasOwnProperty("$gte"))
    return {
      $comparator: !0,
      $op: t ? function(s) {
        return new Date(s[2]) >= new Date(e.$gte);
      } : function(s) {
        return s[2] >= e.$gte;
      }
    };
  if (e.hasOwnProperty("$lt"))
    return {
      $comparator: !0,
      $op: t ? function(s) {
        return new Date(s[2]) < new Date(e.$lt);
      } : function(s) {
        return s[2] < e.$lt;
      }
    };
  if (e.hasOwnProperty("$lte"))
    return {
      $comparator: !0,
      $op: t ? function(s) {
        return new Date(s[2]) <= new Date(e.$lte);
      } : function(s) {
        return s[2] <= e.$lte;
      }
    };
  if (e.hasOwnProperty("$like")) {
    const r = Dt(!0, e.$like);
    return {
      $comparator: !0,
      $op: function(i) {
        return r(i[2]);
      }
    };
  }
  if (e.hasOwnProperty("$ilike")) {
    const r = Dt(!1, e.$ilike);
    return {
      $comparator: !0,
      $op: function(i) {
        return r(i[2]);
      }
    };
  }
  return e;
}
function ps(n, e, t, r, s, i) {
  const o = C(e, t, s), a = X(
    e,
    t,
    s
  ), c = o || a;
  if (!c)
    throw new se(
      `No attr for etype = ${t} label = ${s}`
    );
  if (i != null && i.hasOwnProperty("$isNull")) {
    const u = C(e, t, "id");
    if (!u)
      throw new se(
        `No attr for etype = ${t} label = id`
      );
    return [
      n(t, r),
      u.id,
      { $isNull: { attrId: c.id, isNull: i.$isNull, reverse: !o } },
      fe("time")
    ];
  }
  return o ? [
    n(t, r),
    c.id,
    hs(c, i),
    fe("time")
  ] : [i, c.id, n(t, r), fe("time")];
}
function ys(n, e, t, r, s) {
  const [i, o, a] = s.reduce(
    (c, u) => {
      const [l, f, d] = c, [h, p, b] = On(
        n,
        e,
        l,
        f,
        u
      );
      return [h, p, [...d, b]];
    },
    [t, r, []]
  );
  return [i, o, a];
}
function Je(n, e, t, r, s, i) {
  const o = s.slice(0, s.length - 1), a = s[s.length - 1], [c, u, l] = ys(
    n,
    e,
    t,
    r,
    o
  ), f = ps(
    n,
    e,
    c,
    u,
    a,
    i
  );
  return l.concat([f]);
}
function bs(n, e) {
  return e ? [e].concat(n) : n;
}
function gs([n, e]) {
  return n === "or" && Array.isArray(e);
}
function _s([n, e]) {
  return n === "and" && Array.isArray(e);
}
function ws(n, e, t) {
  return (r, s) => {
    const i = n(r, s);
    return e == i ? i : `${i}-${t}`;
  };
}
function Rt(n, e, t, r, s, i) {
  const o = n(r, s), a = i.map((c, u) => {
    const l = ws(n, o, u);
    return vn(l, t, r, s, c);
  });
  return { [e]: { patterns: a, joinSym: o } };
}
function Ts(n) {
  const e = [];
  for (let t = 1; t <= n.length; t++)
    e.push(n.slice(0, t));
  return e;
}
function xt(n, e, t, r, s) {
  return Ts(s).map(
    (i) => Je(n, e, t, r, i, {
      $isNull: !0
    })
  );
}
function vn(n, e, t, r, s) {
  return Object.entries(s).flatMap(([i, o]) => {
    if (gs([i, o]))
      return Rt(n, "or", e, t, r, o);
    if (_s([i, o]))
      return Rt(n, "and", e, t, r, o);
    if (i === "$entityIdStartsWith")
      return [];
    const a = i.split(".");
    if (o != null && o.hasOwnProperty("$ne") && (o = { ...o, $not: o.$ne }, delete o.$ne), o != null && o.hasOwnProperty("$not")) {
      const c = Je(
        n,
        e,
        t,
        r,
        a,
        o
      ), u = xt(
        n,
        e,
        t,
        r,
        a
      );
      return [
        {
          or: {
            patterns: [c, ...u],
            joinSym: n(t, r)
          }
        }
      ];
    }
    return o != null && o.hasOwnProperty("$isNull") && o.$isNull === !0 && a.length > 1 ? [
      {
        or: {
          patterns: xt(
            n,
            e,
            t,
            r,
            a
          ),
          joinSym: n(t, r)
        }
      }
    ] : Je(n, e, t, r, a, o);
  });
}
function ms(n, e, t, r) {
  const s = Pe;
  return r ? vn(s, n, e, t, r).concat($t(s, n, e, t)) : $t(s, n, e, t);
}
function Ss(n, e, t) {
  return [n(e, t), n("time", t)];
}
function As(n, e, t, r, s, i) {
  const [o, a, c, u, l] = On(
    n,
    e,
    t,
    r,
    s
  ), f = ds(c, n(t, r), i);
  return [o, a, f, u, l];
}
function Os(n, e, t, { etype: r, level: s, form: i }, o) {
  const a = Object.keys(i).filter((c) => c !== "$");
  return a.length ? Object.entries(o).map(function([u, l]) {
    return a.map(function(h) {
      var b, _, g;
      const p = !!(e.cardinalityInference && ((g = (_ = (b = t.linkIndex) == null ? void 0 : b[r]) == null ? void 0 : _[h]) != null && g.isSingular));
      try {
        const [y, w, S] = As(
          n,
          t,
          r,
          s,
          h,
          u
        ), m = En(e, t, {
          etype: y,
          level: w,
          form: i[h],
          join: S
        }), v = p ? m[0] : m;
        return { [h]: v };
      } catch (y) {
        if (y instanceof se)
          return { [h]: p ? void 0 : [] };
        throw y;
      }
    }).reduce(function(h, p) {
      return { ...h, ...p };
    }, l);
  }) : Object.values(o);
}
function vs(n, e, t) {
  return t === "string" ? cs(n, e) : n > e ? 1 : -1;
}
function ue(n, e, t, r, s) {
  return e === r || e == null && r == null ? is(n, t) : r == null ? 1 : e == null ? -1 : vs(e, r, s);
}
function Ie([n, e], [t, r], s) {
  return ue(n, e, t, r, s);
}
function Ye(n) {
  return n == null ? n : new Date(n).getTime();
}
function ks(n, e, t, r) {
  var p;
  const [s, i, o, a] = n, c = t === "desc" ? 1 : -1;
  if (((p = e["forward-identity"]) == null ? void 0 : p[2]) === "id")
    return Ie(r, [s, a], null) === c;
  const [u, l] = r, f = e["checked-data-type"], d = f === "date" ? Ye(l) : l, h = f === "date" ? Ye(o) : o;
  return Ie([u, d], [s, h], f) === c;
}
function Es(n, e) {
  const t = e[1];
  return n.getAttr(t);
}
function Is(n, e, t) {
  const r = Object.keys(t)[0];
  return C(n, e, r);
}
function Cs(n, e, t, r) {
  if (t)
    return Es(n, t);
  if (r)
    return Is(n, e, r);
}
function Ms(n, e, t) {
  var s, i;
  if (!Array.isArray(t.fields))
    return Nr(n, e);
  const r = /* @__PURE__ */ new Map();
  for (const o of t.fields) {
    const a = C(n, e, o), c = (s = a == null ? void 0 : a["forward-identity"]) == null ? void 0 : s[2];
    c && yt(a) && r.set(c, a);
  }
  if (!r.has("id")) {
    const o = C(n, e, "id"), a = (i = o == null ? void 0 : o["forward-identity"]) == null ? void 0 : i[2];
    a && r.set(a, o);
  }
  return r;
}
function Ps(n, e, { etype: t, pageInfo: r, dq: s, form: i }) {
  var p, b;
  const o = (p = i == null ? void 0 : i.$) == null ? void 0 : p.order, a = kn(i), c = js(i);
  let u = Jr(n, s);
  const l = r == null ? void 0 : r["start-cursor"], f = Cs(e, t, l, o);
  if (f && ((b = f == null ? void 0 : f["forward-identity"]) == null ? void 0 : b[2]) !== "id") {
    const _ = f["checked-data-type"] === "date", g = f.id;
    u = u.map(([y]) => {
      var S, m, v, O, L;
      let w = (L = (O = (v = (m = (S = n.eav.get(y)) == null ? void 0 : S.get(g)) == null ? void 0 : m.values()) == null ? void 0 : v.next()) == null ? void 0 : O.value) == null ? void 0 : L[2];
      return _ && (w = Ye(w)), [y, w];
    });
  }
  u.sort(
    c === "asc" ? function(g, y) {
      return Ie(g, y, f == null ? void 0 : f["checked-data-type"]);
    } : function(g, y) {
      return Ie(y, g, f == null ? void 0 : f["checked-data-type"]);
    }
  );
  let d = {};
  const h = Ms(e, t, s);
  for (const _ of u) {
    const [g] = _;
    if (d[g] || !a && l && f && ks(l, f, c, _))
      continue;
    const y = Lr(n, h, g);
    y && (d[g] = y);
  }
  return d;
}
function js(n) {
  var t;
  const e = (t = n.$) == null ? void 0 : t.order;
  return e && e[Object.keys(e)[0]] || "asc";
}
function kn(n) {
  var s, i, o;
  const e = (s = n.$) == null ? void 0 : s.offset, t = (i = n.$) == null ? void 0 : i.before, r = (o = n.$) == null ? void 0 : o.after;
  return !e && !t && !r;
}
function $s(n, e, { etype: t, level: r, form: s, join: i, pageInfo: o }) {
  var d, h, p, b, _;
  if (!kn(s) && (!o || !o["start-cursor"]))
    return [];
  const a = bs(
    ms(e, t, r, (d = s.$) == null ? void 0 : d.where),
    i
  ), c = Ss(Pe, t, r), u = (h = s.$) == null ? void 0 : h.fields, l = Ps(n, e, {
    etype: t,
    pageInfo: o,
    form: s,
    dq: { where: a, find: c, fields: u }
  }), f = ((p = s.$) == null ? void 0 : p.limit) || ((b = s.$) == null ? void 0 : b.first) || ((_ = s.$) == null ? void 0 : _.last);
  if (f != null) {
    r > 0 && console.warn(
      "WARNING: Limits in child queries are only run client-side. Data returned from the server will not have a limit."
    );
    const g = Object.entries(l);
    return g.length <= f ? l : Object.fromEntries(g.slice(0, f));
  }
  return l;
}
function Ds(n, e, t) {
  try {
    return $s(n, e, t);
  } catch (r) {
    if (r instanceof se)
      return {};
    throw r;
  }
}
function En(n, e, t) {
  const r = Ds(n, e, t);
  return Os(Pe, n, e, t, r);
}
function Rs(n) {
  const e = {};
  for (const [t, r] of Object.entries(n))
    e[t] = {
      startCursor: r["start-cursor"],
      endCursor: r["end-cursor"],
      hasNextPage: r["has-next-page?"],
      hasPreviousPage: r["has-previous-page?"]
    };
  return e;
}
function gt({
  store: n,
  attrsStore: e,
  pageInfo: t,
  aggregate: r
}, s) {
  const o = { data: Object.keys(s).reduce(function(c, u) {
    return r != null && r[u] || u === "$$ruleParams" || (c[u] = En(n, e, {
      etype: u,
      form: s[u],
      level: 0,
      pageInfo: t == null ? void 0 : t[u]
    })), c;
  }, {}) };
  return t && (o.pageInfo = Rs(t)), r && (o.aggregate = r), o;
}
function xs() {
  const e = {
    __etype: 1,
    __ops: 1,
    create: 1,
    update: 1,
    link: 1,
    unlink: 1,
    delete: 1,
    merge: 1,
    ruleParams: 1
  };
  return new Set(Object.keys(e));
}
const Us = xs();
function Ze(n, e, t) {
  const r = {
    __etype: n,
    __ops: t
  };
  return new Proxy(r, {
    get: (s, i) => {
      if (i === "__ops") return t;
      if (i === "__etype") return n;
      if (Us.has(i))
        return (o, a) => Ze(n, e, [
          ...t,
          a ? [i, n, e, o, a] : [i, n, e, o]
        ]);
    }
  });
}
function Fo(n, e) {
  return `lookup__${n}__${JSON.stringify(e)}`;
}
function Ce(n) {
  return n.startsWith("lookup__");
}
function In(n) {
  const [e, t, ...r] = n.split("__");
  return [t, JSON.parse(r.join("__"))];
}
function Ls(n) {
  return new Proxy(
    {
      __etype: n
    },
    {
      get(e, t) {
        if (t === "__etype") return n;
        const r = t;
        return Ce(r) ? Ze(n, In(r), []) : Ze(n, r, []);
      }
    }
  );
}
function Cn() {
  return new Proxy(
    {},
    {
      get(n, e) {
        return Ls(e);
      }
    }
  );
}
const qo = Cn();
function Ns(n) {
  return n.__ops;
}
function Fs(n, e) {
  const { attrIdMap: t, refSwapAttrIds: r } = n, s = [];
  for (const o of e) {
    const a = t[o];
    if (a)
      s.push(a);
    else if (Array.isArray(o) && o.length == 2 && t[o[0]]) {
      const [c, u] = o;
      s.push([t[c], u]);
    } else
      s.push(o);
  }
  const [i] = e;
  if ((i === "add-triple" || i === "retract-triple") && r.has(e[2])) {
    const o = s[1];
    s[1] = s[3], s[3] = o;
  }
  return s;
}
function qs(n) {
  if (Array.isArray(n))
    return n;
  const e = Object.entries(n);
  if (e.length !== 1)
    throw new Error(
      "lookup must be an object with a single unique attr and value."
    );
  return e[0];
}
function Ks(n, e, t) {
  return t.indexOf(".") !== -1 && // attr names can have `.` in them, so use the attr we find with a `.`
  // before assuming it's a ref lookup.
  !C(n, e, t);
}
function Xe(n) {
  const [e, t, ...r] = n.split(".");
  if (r.length > 0 || t !== "id")
    throw new Error(`${n} is not a valid lookup attribute.`);
  return e;
}
function zs(n, e, t) {
  if (!Ks(n, e, t))
    return C(n, e, t);
  const r = Xe(t), s = C(n, e, r) || X(n, e, r);
  if (s && s["value-type"] !== "ref")
    throw new Error(`${t} does not reference a valid link attribute.`);
  return s;
}
function et(n) {
  return typeof n == "string" && !Ce(n) ? null : typeof n == "string" && Ce(n) ? In(n) : qs(n);
}
function U(n, e, t) {
  const r = et(t);
  if (r === null)
    return t;
  const [s, i] = r, o = zs(n, e, s);
  if (!o || !o["unique?"])
    throw new Error(`${s} is not a unique attribute.`);
  return [o.id, i];
}
function Mn(n, e, t, r) {
  var o;
  const s = U(n, e, t);
  return Array.isArray(s) ? [[
    "add-triple",
    s,
    (o = C(n, e, "id")) == null ? void 0 : o.id,
    s
  ]].concat(r) : r;
}
function Vs({ attrsStore: n }, [e, t, r]) {
  const s = Object.entries(r).flatMap(([i, o]) => {
    const a = Array.isArray(o) ? o : [o], c = C(n, e, i), u = X(n, e, i);
    return a.map((l) => c ? [
      "add-triple",
      U(n, e, t),
      c.id,
      // Uses `!` because if we get here, we should have created the attr if it doesn't
      // already exist
      U(n, c["reverse-identity"][1], l)
    ] : [
      "add-triple",
      // Uses `!` because if we get here, we should have created the attr if it doesn't
      // already exist
      U(n, u["forward-identity"][1], l),
      u == null ? void 0 : u.id,
      U(n, e, t)
    ]);
  });
  return Mn(n, e, t, s);
}
function Qs({ attrsStore: n }, [e, t, r]) {
  const s = Object.entries(r).flatMap(([i, o]) => {
    const a = Array.isArray(o) ? o : [o], c = C(n, e, i), u = X(n, e, i);
    return a.map((l) => c ? [
      "retract-triple",
      U(n, e, t),
      c.id,
      // Uses `!` because if we get here, we should have created the attr if it doesn't
      // already exist
      U(n, c["reverse-identity"][1], l)
    ] : [
      "retract-triple",
      // Uses `!` because if we get here, we should have created the attr if it doesn't
      // already exist
      U(n, u["forward-identity"][1], l),
      u.id,
      U(n, e, t)
    ]);
  });
  return Mn(n, e, t, s);
}
function Ws(n, e, t, r) {
  var s;
  if (Array.isArray(r)) {
    const [i, o] = r;
    for (const a of n || []) {
      const c = a == null ? void 0 : a.aev.get(i);
      if (c) {
        for (const [u, l, f] of x(c, 2))
          if (f === o)
            return !0;
      }
    }
  } else
    for (const i of n || []) {
      const o = i == null ? void 0 : i.eav.get(r);
      if (o) {
        for (const a of o.keys())
          if (((s = e.getAttr(a)) == null ? void 0 : s["forward-identity"][1]) == t)
            return !0;
      }
    }
  return !1;
}
function Pn({ stores: n, attrsStore: e }, [t, r, s, i]) {
  return (i == null ? void 0 : i.upsert) === !1 ? { mode: "update" } : (i == null ? void 0 : i.upsert) === !0 ? null : Ws(n, e, t, r) ? { mode: "update" } : null;
}
function Gs(n, e) {
  const { attrsStore: t } = n, [r, s, i, o] = e, a = ht(i), c = U(t, r, s);
  return [["id", c]].concat(Object.entries(a)).map(([l, f]) => {
    const d = C(t, r, l);
    return d["checked-data-type"] === "date" && n.useDateObjects && (f = Me(f)), ["add-triple", c, d.id, f, { mode: "create" }];
  });
}
function Bs(n, e) {
  const { attrsStore: t } = n, [r, s, i, o] = e, a = ht(i), c = U(t, r, s), u = Pn(n, [r, c, i, o]);
  return [["id", c]].concat(Object.entries(a)).map(([f, d]) => {
    const h = C(t, r, f);
    return h["checked-data-type"] === "date" && n.useDateObjects && (d = Me(d)), [
      "add-triple",
      c,
      h.id,
      d,
      ...u ? [u] : []
    ];
  });
}
function Hs({ attrsStore: n }, [e, t]) {
  return [["delete-entity", U(n, e, t), e]];
}
function Js(n, e) {
  const { attrsStore: t } = n, [r, s, i, o] = e, a = ht(i), c = U(t, r, s), u = Pn(n, [r, c, i, o]), l = Object.entries(a).map(([d, h]) => {
    const p = C(t, r, d);
    return [
      "deep-merge-triple",
      c,
      p.id,
      h,
      ...u ? [u] : []
    ];
  });
  return [[
    "add-triple",
    c,
    C(t, r, "id").id,
    c,
    ...u ? [u] : []
  ]].concat(l);
}
function Ys({ attrsStore: n }, [e, t, r]) {
  return [["rule-params", U(n, e, t), e, r]];
}
function Zs(n) {
  const [e, t, r, s, i] = n;
  if (!s)
    return n;
  const o = { ...s };
  return delete o.id, [e, t, r, o, ...i ? [i] : []];
}
function Xs(n, e) {
  const [t, ...r] = Zs(e);
  switch (t) {
    case "merge":
      return Js(n, r);
    case "create":
      return Gs(n, r);
    case "update":
      return Bs(n, r);
    case "link":
      return Vs(n, r);
    case "unlink":
      return Qs(n, r);
    case "delete":
      return Hs(n, r);
    case "ruleParams":
      return Ys(n, r);
    default:
      throw new Error(`unsupported action ${t}`);
  }
}
function ei(n) {
  switch (n) {
    case "string":
    case "date":
    case "boolean":
    case "number":
      return n;
    default:
      return;
  }
}
function ti(n, e, t) {
  var a, c;
  const r = (c = (a = n.entities[e]) == null ? void 0 : a.attrs) == null ? void 0 : c[t];
  if (t === "id") return null;
  if (!r)
    throw new Error(`${e}.${t} does not exist in your schema`);
  const { unique: s, indexed: i } = r == null ? void 0 : r.config, o = ei(r == null ? void 0 : r.valueType);
  return {
    "index?": i,
    "unique?": s,
    "checked-data-type": o
  };
}
function _e(n, e, t, r) {
  const s = n ? ti(n, e, t) : null, i = P(), a = [P(), e, t];
  return {
    id: i,
    "forward-identity": a,
    "value-type": "blob",
    cardinality: "one",
    "unique?": !1,
    "index?": !1,
    isUnsynced: !0,
    ...s || {},
    ...r || {}
  };
}
function ni(n, e, t) {
  return Object.values(n.links).find((i) => i.forward.on === e && i.forward.label === t || i.reverse.on === e && i.reverse.label === t);
}
function ri(n, e, t) {
  const r = ni(n, e, t);
  if (!r)
    throw new Error(`Couldn't find the link ${e}.${t} in your schema`);
  const { forward: s, reverse: i } = r;
  return {
    "forward-identity": [P(), s.on, s.label],
    "reverse-identity": [P(), i.on, i.label],
    cardinality: s.has === "one" ? "one" : "many",
    "unique?": i.has === "one",
    "on-delete": s.onDelete,
    "on-delete-reverse": i.onDelete
  };
}
function Ut(n, e, t, r) {
  const s = n ? ri(n, e, t) : null, i = P(), o = [P(), e, t], a = [P(), t, e];
  return {
    id: i,
    // @ts-ignore: ts thinks it's any[]
    "forward-identity": o,
    // @ts-ignore: ts thinks it's any[]
    "reverse-identity": a,
    "value-type": "ref",
    // @ts-ignore: ts thinks it's type string
    cardinality: "many",
    "unique?": !1,
    "index?": !1,
    isUnsynced: !0,
    ...s || {},
    ...r || {}
  };
}
const si = /* @__PURE__ */ new Set(["create", "update", "merge", "link", "unlink"]), ii = /* @__PURE__ */ new Set(["link", "unlink"]), oi = /* @__PURE__ */ new Set(["create", "update", "merge"]), ai = /* @__PURE__ */ new Set([
  "link",
  "unlink",
  "create",
  "update",
  "merge",
  "delete",
  "ruleParams"
]), tt = { "unique?": !0, "index?": !0 }, ci = {
  ...tt,
  cardinality: "one"
};
function ui(n) {
  const e = [], [t, r, s, i] = n;
  if (!ai.has(t))
    return e;
  const o = et(s);
  if (o && e.push({ etype: r, lookupPair: o }), t === "link")
    for (const [a, c] of Object.entries(i)) {
      const u = Array.isArray(c) ? c : [c];
      for (const l of u) {
        const f = et(l);
        f && e.push({
          etype: r,
          lookupPair: f,
          linkLabel: a
        });
      }
    }
  return e;
}
function li({ attrsStore: n, schema: e }, t) {
  var d, h;
  const r = /* @__PURE__ */ new Set(), s = [], i = [];
  function o(p, b) {
    return C(n, p, b) || s.find(
      (_) => _["forward-identity"][1] === p && _["forward-identity"][2] === b
    );
  }
  function a(p, b) {
    return X(n, p, b) || s.find(
      (_) => {
        var g, y;
        return ((g = _["reverse-identity"]) == null ? void 0 : g[1]) === p && ((y = _["reverse-identity"]) == null ? void 0 : y[2]) === b;
      }
    );
  }
  function c(p) {
    s.push(p), i.push(["add-attr", p]), r.add(p.id);
  }
  function u(p) {
    p && "isUnsynced" in p && p.isUnsynced && !r.has(p.id) && (s.push(p), i.push(["add-attr", p]), r.add(p.id));
  }
  function l(p, b) {
    return b.indexOf(".") !== -1 && // attr names can have `.` in them, so use the attr we find with a `.`
    // before assuming it's a ref lookup.
    !o(p, b);
  }
  function f(p, b) {
    const _ = o(p, b), g = a(p, b);
    u(_), u(g), !_ && !g && c(Ut(e, p, b, ci));
  }
  for (const p of t)
    for (const { etype: b, lookupPair: _, linkLabel: g } of ui(p)) {
      const y = _[0];
      if (g) {
        f(b, g);
        const w = o(b, g), S = a(b, g);
        u(w), u(S);
        const m = ((d = w == null ? void 0 : w["reverse-identity"]) == null ? void 0 : d[1]) || ((h = S == null ? void 0 : S["forward-identity"]) == null ? void 0 : h[1]) || g;
        if (l(m, y))
          f(m, Xe(y));
        else {
          const v = o(m, y);
          v || c(
            _e(e, m, y, tt)
          ), u(v);
        }
      } else if (l(b, y))
        f(b, Xe(y));
      else {
        const w = o(b, y);
        w || c(_e(e, b, y, tt)), u(w);
      }
    }
  for (const p of t) {
    const [b, _, g, y] = p;
    if (si.has(b)) {
      const w = o(_, "id");
      u(w), w || c(_e(e, _, "id", { "unique?": !0 }));
      for (const S of Object.keys(y)) {
        const m = o(_, S);
        if (u(m), oi.has(b) && (m || c(
          _e(
            e,
            _,
            S,
            S === "id" ? { "unique?": !0 } : null
          )
        )), ii.has(b)) {
          const v = a(_, S);
          !m && !v && c(Ut(e, _, S)), u(v);
        }
      }
    }
  }
  if (s.length) {
    const p = { ...n.attrs };
    for (const b of s)
      p[b.id] = b;
    return [new H(p, n.linkIndex), i];
  }
  return [n, i];
}
function fi(n, e) {
  const r = (Array.isArray(e) ? e : [e]).flatMap((c) => Ns(c)), [s, i] = li(n, r), o = { ...n, attrsStore: s }, a = r.flatMap((c) => Xs(o, c));
  return [...i, ...a];
}
function Lt(n, e) {
  typeof requestIdleCallback > "u" ? n() : requestIdleCallback(n, { timeout: e });
}
const de = "__meta";
class di {
  constructor(e, t) {
  }
}
class nt {
  constructor(e) {
    this._subs = [], this._nextSave = null, this._nextGc = null, this._pendingSaveKeys = /* @__PURE__ */ new Set(), this._loadedKeys = /* @__PURE__ */ new Set(), this._version = 0, this._meta = {
      isLoading: !0,
      onLoadCbs: [],
      value: null,
      error: null,
      attempts: 0
    }, this._persister = e.persister, this._merge = e.merge, this.serialize = e.serialize, this.parse = e.parse, this._objectSize = e.objectSize, this._log = e.logger, this._saveThrottleMs = e.saveThrottleMs ?? 100, this._idleCallbackMaxWaitMs = e.idleCallbackMaxWaitMs ?? 1e3, this._gcOpts = e.gc, this.currentValue = {}, this._loadedKeys = /* @__PURE__ */ new Set(), this._loadingKeys = {}, this._initMeta(), e.preloadEntryCount && this._preloadEntries(e.preloadEntryCount);
  }
  async _initMeta() {
    var e;
    this._meta.loadingPromise && await this._meta.loadingPromise;
    try {
      const t = this._persister.getItem(de);
      this._meta.loadingPromise = t;
      const r = await t;
      this._meta.isLoading = !1, this._meta.error = null, this._meta.loadingPromise = null, this._meta.attempts = 0;
      const s = ((e = this._meta.value) == null ? void 0 : e.objects) ?? {}, i = r ?? {}, o = i.objects ?? {};
      this._meta.value = {
        ...i,
        objects: { ...s, ...o }
      };
    } catch (t) {
      this._meta.error = t, this._meta.attempts++, this._meta.loadingPromise = null;
    }
  }
  async _getMeta() {
    return this._meta.value ? this._meta.value : this._meta.loadingPromise ? (await this._meta.loadingPromise, this._meta.value) : (this._initMeta(), await this._meta.loadingPromise, this._meta.value);
  }
  async _refreshMeta() {
    return await this._initMeta(), this._meta.value;
  }
  async _preloadEntries(e) {
    const t = await this.waitForMetaToLoad();
    if (!t) return;
    const r = Object.entries(t.objects);
    r.sort(([s, i], [o, a]) => a.updatedAt - i.updatedAt);
    for (const [s] of r.slice(0, e))
      this._loadKey(s);
  }
  async _getFromStorage(e) {
    try {
      const t = await this._persister.getItem(e);
      return t && this.parse(e, t);
    } catch (t) {
      return console.error(`Unable to read from storage for key=${e}`, t), null;
    }
  }
  async waitForKeyToLoad(e) {
    return this._loadedKeys.has(e) ? this.currentValue[e] : (await (this._loadingKeys[e] || this._loadKey(e)), this.currentValue[e]);
  }
  // Used for tests
  async waitForMetaToLoad() {
    return this._getMeta();
  }
  // Unloads the key so that it can be garbage collected, but does not
  // delete it. Removes the key from currentValue.
  unloadKey(e) {
    this._loadedKeys.delete(e), delete this._loadingKeys[e], delete this.currentValue[e];
  }
  async _loadKey(e) {
    if (this._loadedKeys.has(e) || e in this._loadingKeys) return;
    const t = this._getFromStorage(e);
    this._loadingKeys[e] = t;
    const r = await t;
    if (delete this._loadingKeys[e], this._loadedKeys.add(e), r) {
      const s = this._merge(e, r, this.currentValue[e]);
      s && (this.currentValue[e] = s);
    }
    this.onKeyLoaded && this.onKeyLoaded(e);
  }
  // Returns a promise with a number so that we can wait for flush
  // to finish in the tests. The number is the number of operations
  // it performed, but it's mostly there so that typescript will warn
  // us if we forget to retun the promise from the function.
  _writeToStorage(e) {
    const t = [], r = e == null ? void 0 : e.skipGc;
    if (this._meta.isLoading) {
      const f = new Promise((d, h) => {
        setTimeout(
          () => this._enqueuePersist(
            e ? { ...e, attempts: (e.attempts || 0) + 1 } : { attempts: 1 }
          ).then(d).catch(h),
          10 + ((e == null ? void 0 : e.attempts) ?? 0) * 1e3
        );
      });
      return t.push(f), Promise.all(t).then(
        (d) => d.reduce((h, p) => h + p, 0)
      );
    }
    const s = this._meta.value;
    if (!s)
      return Promise.resolve(0);
    const i = [], o = [];
    for (const f of this._pendingSaveKeys)
      f in this.currentValue ? o.push(f) : (i.push(f), delete s.objects[f]);
    for (const f of i) {
      const d = this._persister.removeItem(f);
      t.push(d.then(() => 1)), this._loadedKeys.delete(f), this._pendingSaveKeys.delete(f);
    }
    const a = [], c = [[de, s]], u = s.objects ?? {};
    s.objects = u;
    for (const f of o)
      if (this._loadedKeys.has(f)) {
        const d = this.serialize(f, this.currentValue[f]);
        c.push([f, d]);
        const h = this._objectSize(d), p = u[f] ?? {
          createdAt: Date.now(),
          updatedAt: Date.now(),
          size: h
        };
        p.updatedAt = Date.now(), p.size = h, u[f] = p, this._pendingSaveKeys.delete(f);
      } else
        a.push(f);
    const l = this._persister.multiSet(c);
    t.push(l.then(() => 1));
    for (const f of a) {
      const d = this._loadKey(f).then(() => this._enqueuePersist(e));
      t.push(d);
    }
    return r || this.gc(), Promise.all(t).then((f) => f.reduce((d, h) => d + h, 0));
  }
  async flush() {
    return this._nextSave ? (clearTimeout(this._nextSave), this._nextSave = null, this._writeToStorage()) : void 0;
  }
  async _gc() {
    if (!this._gcOpts)
      return;
    const e = new Set(await this._persister.getAllKeys());
    e.delete(de);
    const t = new Set(Object.keys(this.currentValue));
    for (const d of Object.keys(this._loadingKeys))
      t.add(d);
    for (const d of this._loadedKeys)
      t.add(d);
    const r = await this._refreshMeta();
    if (!r) {
      this._log.info("Could not gc because we were not able to load meta");
      return;
    }
    const s = [], i = {
      gcOpts: this._gcOpts,
      keys: e,
      sacredKeys: t,
      removed: [],
      metaRemoved: [],
      removedMissingCount: 0,
      removedOldCount: 0,
      removedThresholdCount: 0,
      removedSizeCount: 0
    };
    for (const d of e)
      t.has(d) || d in r.objects || (this._log.info("Lost track of key in meta", d), s.push(this._persister.removeItem(d)), i.removed.push(d), i.removedMissingCount++);
    const o = Date.now();
    for (const [d, h] of Object.entries(r.objects))
      !t.has(d) && h.updatedAt < o - this._gcOpts.maxAgeMs && (s.push(this._persister.removeItem(d)), delete r.objects[d], i.removed.push(d), i.removedOldCount++);
    const a = Object.entries(r.objects);
    a.sort(([d, h], [p, b]) => h.updatedAt - b.updatedAt);
    const c = a.filter(([d]) => !t.has(d));
    if (a.length > this._gcOpts.maxEntries)
      for (const [d] of c.slice(
        0,
        a.length - this._gcOpts.maxEntries
      ))
        s.push(this._persister.removeItem(d)), delete r.objects[d], i.removed.push(d), i.removedThresholdCount++;
    const u = Object.entries(r.objects);
    u.sort(([d, h], [p, b]) => h.updatedAt - b.updatedAt);
    const l = u.filter(([d]) => !t.has(d));
    let f = u.reduce((d, [h, p]) => d + p.size, 0);
    for (; f > 0 && f > this._gcOpts.maxSize && l.length; ) {
      const [[d, h]] = l.splice(0, 1);
      f -= h.size, s.push(this._persister.removeItem(d)), delete r.objects[d], i.removed.push(d), i.removedSizeCount++;
    }
    for (const d of Object.keys(r.objects))
      !e.has(d) && !t.has(d) && delete r.objects[d];
    return (i.removed.length || i.metaRemoved.length) && s.push(this._enqueuePersist({ skipGc: !0 })), this._log.info("Completed GC", i), await Promise.all(s), i;
  }
  // Schedules a GC to run in one minute (unless it is already scheduled)
  gc() {
    this._nextGc || (this._nextGc = setTimeout(
      () => {
        Lt(() => {
          this._nextGc = null, this._gc();
        }, 30 * 1e3);
      },
      // 1 minute + some jitter to keep multiple tabs from running at same time
      1e3 * 60 + Math.random() * 500
    ));
  }
  _enqueuePersist(e) {
    return new Promise((t, r) => {
      if (this._nextSave) {
        t(0);
        return;
      }
      this._nextSave = setTimeout(() => {
        Lt(() => {
          this._nextSave = null, this._writeToStorage(e).then(t).catch(r);
        }, this._idleCallbackMaxWaitMs);
      }, this._saveThrottleMs);
    });
  }
  version() {
    return this._version;
  }
  // Takes a function that updates the store in place.
  // Uses `mutative` to get a list of keys that were changed
  // so that we know which entries we need to persist to the store.
  updateInPlace(e) {
    this._version++;
    const [t, r] = Ee(this.currentValue, e, {
      enablePatches: !0
    });
    for (const s of r) {
      const i = s.path[0];
      i && typeof i == "string" && (this._pendingSaveKeys.add(i), this._loadedKeys.has(i) || this._loadKey(i));
    }
    this.currentValue = t, this._enqueuePersist();
    for (const s of this._subs)
      s(this.currentValue);
    return t;
  }
  subscribe(e) {
    return this._subs.push(e), e(this.currentValue), () => {
      this._subs = this._subs.filter((t) => t !== e);
    };
  }
}
const hi = 6, pi = ["kv", "querySubs", "syncSubs"];
function yi(n) {
  return function(t) {
    console.error("Error in IndexedDB event", { source: n, event: t });
  };
}
async function bi(n) {
  return new Promise((e) => {
    const t = indexedDB.open(n);
    t.onerror = (r) => {
      e(null);
    }, t.onsuccess = (r) => {
      const i = r.target.result;
      e(i);
    }, t.onupgradeneeded = (r) => {
      var i;
      (i = r.target.transaction) == null || i.abort(), e(null);
    };
  });
}
async function gi(n, e, t) {
  const r = (
    // Backwards compatibility for older versions where we JSON.stringified before storing
    typeof e == "string" ? JSON.parse(e) : e
  );
  if (!r)
    return;
  const s = /* @__PURE__ */ new Set();
  return new Promise((i, o) => {
    var l, f, d;
    const a = {};
    for (const [h, p] of Object.entries(r)) {
      const b = typeof p == "string" ? JSON.parse(p) : p;
      if (b.lastAccessed) {
        const g = {
          createdAt: b.lastAccessed,
          updatedAt: b.lastAccessed,
          size: ((d = (f = (l = b.result) == null ? void 0 : l.store) == null ? void 0 : f.triples) == null ? void 0 : d.length) ?? 0
        };
        a[h] = g;
      }
      const _ = t.put(b, h);
      s.add(_);
    }
    const c = { objects: a }, u = t.put(c, de);
    s.add(u);
    for (const h of s)
      h.onsuccess = () => {
        s.delete(h), s.size === 0 && i();
      }, h.onerror = (p) => {
        o(p);
      };
  });
}
async function Nt(n, e, t) {
  const r = t.put(e, n);
  return new Promise((s, i) => {
    r.onsuccess = () => s(), r.onerror = (o) => i(o);
  });
}
async function _i(n, e) {
  const t = await bi(`instant_${n}_5`);
  if (!t)
    return;
  const r = await new Promise((l, f) => {
    const p = t.transaction(["kv"], "readonly").objectStore("kv").openCursor();
    p.onerror = (_) => {
      f(_);
    };
    const b = [];
    p.onsuccess = () => {
      const _ = p.result;
      if (_) {
        const g = _.key, y = _.value;
        b.push([g, y]), _.continue();
      } else
        l(b);
    }, p.onerror = (_) => {
      f(_);
    };
  }), s = e.transaction(["kv", "querySubs"], "readwrite"), i = s.objectStore("kv"), o = s.objectStore("querySubs"), a = [], c = { objects: {} };
  for (const [l, f] of r)
    switch (l) {
      case "querySubs": {
        const d = gi(l, f, o);
        a.push(d);
        break;
      }
      default: {
        const d = Nt(l, f, i);
        a.push(d);
        const h = {
          createdAt: Date.now(),
          updatedAt: Date.now(),
          size: 0
        };
        c.objects[l] = h;
        break;
      }
    }
  const u = Nt(de, c, i);
  a.push(u), await Promise.all(a), await new Promise((l, f) => {
    s.oncomplete = (d) => l(d), s.onerror = (d) => f(d), s.onabort = (d) => f(d);
  });
}
const Ft = /* @__PURE__ */ new Map();
class jn extends di {
  constructor(e, t) {
    super(e, t), this.dbName = `instant_${e}_${hi}`, this._storeName = t, this._appId = e, this._dbPromise = this._init();
  }
  _init() {
    return new Promise((e, t) => {
      let r = !1;
      const s = indexedDB.open(this.dbName, 1);
      s.onerror = (i) => {
        t(i);
      }, s.onsuccess = (i) => {
        const a = i.target.result;
        if (r) {
          const c = _i(this._appId, a).catch((u) => {
            yi("Error upgrading store from version 5 to 6.")(u);
          });
          Ft.set(this.dbName, c), c.then(() => e(a)).catch(() => e(a));
        } else {
          const c = Ft.get(this.dbName);
          c ? c.then(() => e(a)).catch(() => e(a)) : e(a);
        }
      }, s.onupgradeneeded = (i) => {
        r = !0, this._upgradeStore(i);
      };
    });
  }
  _upgradeStore(e) {
    const r = e.target.result;
    for (const s of pi)
      r.objectStoreNames.contains(s) || r.createObjectStore(s);
  }
  async getItem(e) {
    const t = await this._dbPromise;
    return new Promise((r, s) => {
      const a = t.transaction([this._storeName], "readonly").objectStore(this._storeName).get(e);
      a.onerror = (c) => {
        s(c);
      }, a.onsuccess = (c) => {
        a.result ? r(a.result) : r(null);
      };
    });
  }
  async setItem(e, t) {
    const r = await this._dbPromise;
    return new Promise((s, i) => {
      const c = r.transaction([this._storeName], "readwrite").objectStore(this._storeName).put(t, e);
      c.onerror = (u) => {
        i(u);
      }, c.onsuccess = (u) => {
        s();
      };
    });
  }
  // Performs all writes in a transaction so that all succeed or none succeed.
  async multiSet(e) {
    const t = await this._dbPromise;
    return new Promise((r, s) => {
      const i = t.transaction([this._storeName], "readwrite"), o = i.objectStore(this._storeName), a = /* @__PURE__ */ new Set();
      for (const [c, u] of e) {
        const l = o.put(u, c);
        a.add(l);
      }
      for (const c of a)
        c.onerror = (u) => {
          i.abort(), s(u);
        }, c.onsuccess = (u) => {
          a.delete(c), a.size === 0 && r();
        };
    });
  }
  async removeItem(e) {
    const t = await this._dbPromise;
    return new Promise((r, s) => {
      const a = t.transaction([this._storeName], "readwrite").objectStore(this._storeName).delete(e);
      a.onerror = (c) => {
        s(c);
      }, a.onsuccess = (c) => {
        r();
      };
    });
  }
  async getAllKeys() {
    const e = await this._dbPromise;
    return new Promise((t, r) => {
      const o = e.transaction([this._storeName], "readonly").objectStore(this._storeName).getAllKeys();
      o.onerror = (a) => {
        r(a);
      }, o.onsuccess = (a) => {
        t(o.result.filter((c) => typeof c == "string"));
      };
    });
  }
}
class $n {
  static async getIsOnline() {
    return navigator.onLine;
  }
  static listen(e) {
    const t = () => {
      e(!0);
    }, r = () => {
      e(!1);
    };
    return addEventListener("online", t), addEventListener("offline", r), () => {
      removeEventListener("online", t), removeEventListener("offline", r);
    };
  }
}
class pe extends Error {
  constructor(e, t) {
    super(e), this.hint = t;
    const r = new.target.prototype;
    Object.setPrototypeOf && Object.setPrototypeOf(this, r), Error.captureStackTrace && Error.captureStackTrace(this, pe), this.name = "InstantError";
  }
  get [Symbol.toStringTag]() {
    return "InstantError";
  }
}
class je extends pe {
  constructor(e) {
    var s;
    const t = ((s = e.body) == null ? void 0 : s.message) || `API Error (${e.status})`;
    super(t, e.body.hint);
    const r = new.target.prototype;
    Object.setPrototypeOf && Object.setPrototypeOf(this, r), Error.captureStackTrace && Error.captureStackTrace(this, je), this.name = "InstantAPIError", this.status = e.status, this.body = e.body;
  }
  get [Symbol.toStringTag]() {
    return "InstantAPIError";
  }
}
async function V(n, e) {
  const t = await fetch(n, e), r = await t.json();
  return t.status === 200 ? Promise.resolve(r) : Promise.reject(new je({ status: t.status, body: r }));
}
function wi({
  apiURI: n,
  appId: e,
  email: t
}) {
  return V(`${n}/runtime/auth/send_magic_code`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ "app-id": e, email: t })
  });
}
async function Ti({
  apiURI: n,
  appId: e,
  email: t,
  code: r,
  refreshToken: s
}) {
  return await V(`${n}/runtime/auth/verify_magic_code`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      "app-id": e,
      email: t,
      code: r,
      ...s ? { "refresh-token": s } : {}
    })
  });
}
async function mi({
  apiURI: n,
  appId: e,
  refreshToken: t
}) {
  return await V(`${n}/runtime/auth/verify_refresh_token`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      "app-id": e,
      "refresh-token": t
    })
  });
}
async function Si({
  apiURI: n,
  appId: e
}) {
  return await V(`${n}/runtime/auth/sign_in_guest`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      "app-id": e
    })
  });
}
async function qt({
  apiURI: n,
  appId: e,
  code: t,
  codeVerifier: r,
  refreshToken: s
}) {
  return await V(`${n}/runtime/oauth/token`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      app_id: e,
      code: t,
      code_verifier: r,
      refresh_token: s
    })
  });
}
async function Ai({
  apiURI: n,
  appId: e,
  nonce: t,
  idToken: r,
  clientName: s,
  refreshToken: i
}) {
  return await V(`${n}/runtime/oauth/id_token`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      app_id: e,
      nonce: t,
      id_token: r,
      client_name: s,
      refresh_token: i
    })
  });
}
async function Oi({
  apiURI: n,
  appId: e,
  refreshToken: t
}) {
  return await V(`${n}/runtime/signout`, {
    method: "POST",
    headers: {
      "content-type": "application/json"
    },
    body: JSON.stringify({
      app_id: e,
      refresh_token: t
    })
  });
}
async function vi({
  apiURI: n,
  appId: e,
  path: t,
  file: r,
  refreshToken: s,
  contentType: i,
  contentDisposition: o
}) {
  const a = {
    app_id: e,
    path: t,
    authorization: `Bearer ${s}`,
    "content-type": i || r.type
  };
  return o && (a["content-disposition"] = o), await V(`${n}/storage/upload`, {
    method: "PUT",
    headers: a,
    body: r
  });
}
async function ki({
  apiURI: n,
  appId: e,
  path: t,
  refreshToken: r
}) {
  const { data: s } = await V(
    `${n}/storage/files?app_id=${e}&filename=${encodeURIComponent(t)}`,
    {
      method: "DELETE",
      headers: {
        "content-type": "application/json",
        authorization: `Bearer ${r}`
      }
    }
  );
  return s;
}
async function Ei({
  apiURI: n,
  appId: e,
  fileName: t,
  refreshToken: r,
  metadata: s = {}
}) {
  const { data: i } = await V(`${n}/storage/signed-upload-url`, {
    method: "POST",
    headers: {
      "content-type": "application/json",
      authorization: `Bearer ${r}`
    },
    body: JSON.stringify({
      app_id: e,
      filename: t
    })
  });
  return i;
}
async function Ii(n, e) {
  return (await fetch(n, {
    method: "PUT",
    body: e,
    headers: {
      "Content-Type": e.type
    }
  })).ok;
}
async function Ci({
  apiURI: n,
  appId: e,
  path: t,
  refreshToken: r
}) {
  const { data: s } = await V(
    `${n}/storage/signed-download-url?app_id=${e}&filename=${encodeURIComponent(
      t
    )}`,
    {
      method: "GET",
      headers: {
        "content-type": "application/json",
        authorization: `Bearer ${r}`
      }
    }
  );
  return s;
}
let _t = !1, Dn = !1, Rn = !1;
typeof window < "u" && typeof window.localStorage < "u" && (_t = !!window.localStorage.getItem("devBackend"), Dn = !!window.localStorage.getItem("__instantLogging"), Rn = !!window.localStorage.getItem("__devtoolLocalDash"));
function Kt(n, e) {
  if (!e) return n;
  const t = {};
  return e.forEach((r) => {
    t[r] = n[r];
  }), t;
}
function Mi(n, e, t) {
  const r = {
    peers: {}
  };
  if (e && "user" in e ? e.user : !0) {
    const i = Kt(n.user ?? {}, e == null ? void 0 : e.keys);
    r.user = { ...i, peerId: t };
  }
  for (const i of Object.keys(n.peers ?? {})) {
    const o = (e == null ? void 0 : e.peers) === void 0, a = Array.isArray(e == null ? void 0 : e.peers) && (e == null ? void 0 : e.peers.includes(i));
    if (o || a) {
      const c = Kt(n.peers[i], e == null ? void 0 : e.keys);
      r.peers[i] = { ...c, peerId: i };
    }
  }
  return r;
}
function Pi(n, e) {
  if (n.isLoading !== e.isLoading || n.error !== e.error || (n.user || e.user) && (!n.user || !e.user || !Et(n.user, e.user)) || !ln(n.peers, e.peers)) return !0;
  for (const r of Object.keys(n.peers))
    if (!Et(n.peers[r], e.peers[r])) return !0;
  return !1;
}
class zt {
  constructor() {
    T(this, "promise");
    T(this, "_resolve");
    T(this, "_reject");
    this.promise = new Promise((e, t) => {
      this._resolve = e, this._reject = t;
    });
  }
  resolve(e) {
    this._resolve(e);
  }
  reject(e) {
    this._reject(e);
  }
}
function xn(n, e = []) {
  n.forEach((t) => {
    const { data: r } = t, { "datalog-result": s } = r, { "join-rows": i } = s;
    for (const o of i)
      for (const a of o)
        e.push(a);
    xn(t["child-nodes"], e);
  });
}
function Vt(n) {
  const e = [];
  return xn(n, e), e;
}
function rt(n) {
  return Object.values(n.links).reduce((e, t) => {
    var r, s;
    return e[r = t.forward.on] ?? (e[r] = {}), e[t.forward.on][t.forward.label] = {
      isForward: !0,
      isSingular: t.forward.has === "one",
      link: t
    }, e[s = t.reverse.on] ?? (e[s] = {}), e[t.reverse.on][t.reverse.label] = {
      isForward: !1,
      isSingular: t.reverse.has === "one",
      link: t
    }, e;
  }, {});
}
const Un = "v0.22.96";
function ji(n, e) {
  return {
    info: n ? (...t) => console.info(...t, e()) : () => {
    },
    debug: n ? (...t) => console.debug(...t, e()) : () => {
    },
    error: n ? (...t) => console.error(...t, e()) : () => {
    }
  };
}
class D {
  constructor(e, t, r, s = { indexed: !1, unique: !1 }) {
    this.valueType = e, this.required = t, this.isIndexed = r, this.config = s, this.metadata = {};
  }
  /**
   * @deprecated Only use this temporarily for attributes that you want
   * to treat as required in frontend code but cant yet mark as required
   * and enforced for backend
   */
  clientRequired() {
    return new D(
      this.valueType,
      !1,
      this.isIndexed,
      this.config
    );
  }
  optional() {
    return new D(
      this.valueType,
      !1,
      this.isIndexed,
      this.config
    );
  }
  unique() {
    return new D(
      this.valueType,
      this.required,
      this.isIndexed,
      {
        ...this.config,
        unique: !0
      }
    );
  }
  indexed() {
    return new D(
      this.valueType,
      this.required,
      !0,
      {
        ...this.config,
        indexed: !0
      }
    );
  }
  // clientValidate(clientValidator: (value: ValueType) => boolean) {
  //   return new DataAttrDef(this.valueType, this.required, {
  //     ...this.config,
  //     clientValidator,
  //   });
  // }
}
class $e {
  constructor(e, t) {
    this.attrs = e, this.links = t;
  }
  asType() {
    return new $e(this.attrs, this.links);
  }
}
class De {
  constructor(e, t, r) {
    this.entities = e, this.links = t, this.rooms = r;
  }
  /**
   * @deprecated
   * `withRoomSchema` is deprecated. Define your schema in `rooms` directly:
   *
   * @example
   * // Before:
   * const schema = i.schema({
   *   // ...
   * }).withRoomSchema<RoomSchema>()
   *
   * // After
   * const schema = i.schema({
   *  rooms: {
   *    // ...
   *  }
   * })
   *
   * @see https://instantdb.com/docs/presence-and-topics#typesafety
   */
  withRoomSchema() {
    return new De(
      this.entities,
      this.links,
      {}
    );
  }
}
class k extends Error {
  constructor(e, t) {
    const r = t ? `At path '${t}': ${e}` : e;
    super(r), this.name = "QueryValidationError";
  }
}
const Qt = [
  "where",
  "order",
  "limit",
  "last",
  "first",
  "offset",
  "after",
  "before",
  "fields",
  "aggregate"
], $i = (n) => n.valueType || "unknown", Ln = (n, e, t = !1) => {
  if (t || n == null) return !0;
  switch (e) {
    case "string":
      return typeof n == "string";
    case "number":
      return typeof n == "number" && !isNaN(n);
    case "boolean":
      return typeof n == "boolean";
    case "date":
      return n instanceof Date || typeof n == "string" || typeof n == "number";
    default:
      return !0;
  }
}, Di = (n, e, t, r, s, i, o) => {
  const a = i.valueType === "json", c = (u, l, f) => {
    if (!Ln(f, l, a))
      throw new k(
        `Invalid value for operator '${u}' on attribute '${r}' in entity '${s}'. Expected ${l}, but received: ${typeof f}`,
        o
      );
  };
  switch (n) {
    case "in":
    case "$in":
      if (!Array.isArray(e))
        throw new k(
          `Operator '${n}' for attribute '${r}' in entity '${s}' must be an array, but received: ${typeof e}`,
          o
        );
      for (const u of e)
        c(n, t, u);
      break;
    case "$not":
    case "$ne":
    case "$gt":
    case "$lt":
    case "$gte":
    case "$lte":
      c(n, t, e);
      break;
    case "$like":
    case "$ilike":
      if (c(n, "string", e), n === "$ilike" && !i.isIndexed)
        throw new k(
          `Operator '${n}' can only be used with indexed attributes, but '${r}' in entity '${s}' is not indexed`,
          o
        );
      break;
    case "$isNull":
      c(n, "boolean", e);
      break;
    default:
      throw new k(
        `Unknown operator '${n}' for attribute '${r}' in entity '${s}'`,
        o
      );
  }
}, ne = (n, e, t, r, s) => {
  const i = $i(t), o = t.valueType === "json";
  if (typeof n == "object" && n !== null && !Array.isArray(n)) {
    if (o)
      return;
    const c = n;
    for (const [u, l] of Object.entries(c))
      Di(
        u,
        l,
        i,
        e,
        r,
        t,
        `${s}.${u}`
      );
  } else if (!Ln(n, i, o))
    throw new k(
      `Invalid value for attribute '${e}' in entity '${r}'. Expected ${i}, but received: ${typeof n}`,
      s
    );
}, Ri = (n, e, t, r, s) => {
  const i = n.split(".");
  if (i.length < 2)
    throw new k(
      `Invalid dot notation path '${n}'. Must contain at least one dot.`,
      s
    );
  let o = t;
  for (let l = 0; l < i.length - 1; l++) {
    const f = i[l], d = r.entities[o];
    if (!d)
      throw new k(
        `Entity '${o}' does not exist in schema while traversing dot notation path '${n}'.`,
        s
      );
    const h = d.links[f];
    if (!h) {
      const p = Object.keys(d.links);
      throw new k(
        `Link '${f}' does not exist on entity '${o}' in dot notation path '${n}'. Available links: ${p.length > 0 ? p.join(", ") : "none"}`,
        s
      );
    }
    o = h.entityName;
  }
  const a = i[i.length - 1], c = r.entities[o];
  if (!c)
    throw new k(
      `Target entity '${o}' does not exist in schema for dot notation path '${n}'.`,
      s
    );
  if (a === "id") {
    if (typeof e == "string" && !re(e))
      throw new k(
        `Invalid value for id field in entity '${o}'. Expected a UUID, but received: ${e}`,
        s
      );
    ne(
      e,
      n,
      new D("string", !1, !0),
      t,
      s
    );
    return;
  }
  const u = c.attrs[a];
  if (Object.keys(c.links).includes(a)) {
    if (typeof e == "string" && !re(e))
      throw new k(
        `Invalid value for link '${a}' in entity '${o}'. Expected a UUID, but received: ${e}`,
        s
      );
    ne(
      e,
      n,
      new D("string", !1, !0),
      t,
      s
    );
    return;
  }
  if (!u) {
    const l = Object.keys(c.attrs);
    throw new k(
      `Attribute '${a}' does not exist on entity '${o}' in dot notation path '${n}'. Available attributes: ${l.length > 0 ? l.join(", ") + ", id" : "id"}`,
      s
    );
  }
  ne(e, n, u, t, s);
}, Nn = (n, e, t, r) => {
  for (const [s, i] of Object.entries(n)) {
    if (s === "or" || s === "and") {
      if (Array.isArray(i))
        for (const u of i)
          typeof u == "object" && u !== null && Nn(
            u,
            e,
            t,
            `${r}.${s}[${u}]`
          );
      continue;
    }
    if (s === "id") {
      ne(
        i,
        "id",
        new D("string", !1, !0),
        e,
        `${r}.id`
      );
      continue;
    }
    if (s.includes(".")) {
      Ri(
        s,
        i,
        e,
        t,
        `${r}.${s}`
      );
      continue;
    }
    const o = t.entities[e];
    if (!o) continue;
    const a = o.attrs[s], c = o.links[s];
    if (!a && !c) {
      const u = Object.keys(o.attrs), l = Object.keys(o.links);
      throw new k(
        `Attribute or link '${s}' does not exist on entity '${e}'. Available attributes: ${u.length > 0 ? u.join(", ") : "none"}. Available links: ${l.length > 0 ? l.join(", ") : "none"}`,
        `${r}.${s}`
      );
    }
    if (a)
      ne(
        i,
        s,
        a,
        e,
        `${r}.${s}`
      );
    else if (c) {
      if (typeof i == "string" && !re(i))
        throw new k(
          `Invalid value for link '${s}' in entity '${e}'. Expected a UUID, but received: ${i}`,
          `${r}.${s}`
        );
      const u = new D("string", !1, !0);
      ne(
        i,
        s,
        u,
        e,
        `${r}.${s}`
      );
    }
  }
}, xi = (n, e, t, r, s = 0) => {
  for (const o of Object.keys(n))
    if (!Qt.includes(o))
      throw new k(
        `Invalid query parameter '${o}' in $ object. Valid parameters are: ${Qt.join(", ")}. Found: ${o}`,
        r
      );
  const i = [
    // 'limit', // only supported client side
    "offset",
    "before",
    "after",
    "first",
    "last"
  ];
  for (const o of i)
    if (n[o] !== void 0 && s > 0)
      throw new k(
        `'${o}' can only be used on top-level namespaces. It cannot be used in nested queries.`,
        r
      );
  if (n.where && t) {
    if (typeof n.where != "object" || n.where === null)
      throw new k(
        `'where' clause must be an object in entity '${e}', but received: ${typeof n.where}`,
        r ? `${r}.where` : void 0
      );
    Nn(
      n.where,
      e,
      t,
      r ? `${r}.where` : "where"
    );
  }
}, Fn = (n, e, t, r, s = 0) => {
  var i;
  if (!n || typeof n != "object")
    throw new k(
      `Query part for entity '${e}' must be an object, but received: ${typeof n}`,
      r
    );
  for (const o of Object.keys(n))
    if (o !== "$") {
      if (t && !(o in t.entities[e].links)) {
        const c = Object.keys(t.entities[e].links);
        throw new k(
          `Link '${o}' does not exist on entity '${e}'. Available links: ${c.length > 0 ? c.join(", ") : "none"}`,
          `${r}.${o}`
        );
      }
      const a = n[o];
      if (typeof a == "object" && a !== null) {
        const c = (i = t == null ? void 0 : t.entities[e].links[o]) == null ? void 0 : i.entityName;
        c && Fn(
          a,
          c,
          t,
          `${r}.${o}`,
          s + 1
        );
      }
    } else {
      const a = n[o];
      if (typeof a != "object" || a === null)
        throw new k(
          `Query parameter '$' must be an object in entity '${e}', but received: ${typeof a}`,
          `${r}.$`
        );
      xi(
        a,
        e,
        t,
        `${r}.$`,
        s
      );
    }
}, Wt = (n, e) => {
  if (typeof n != "object" || n === null)
    throw new k(
      `Query must be an object, but received: ${typeof n}${n === null ? " (null)" : ""}`
    );
  if (Array.isArray(n))
    throw new k(
      `Query must be an object, but received: ${typeof n}`
    );
  const t = n;
  for (const r of Object.keys(t)) {
    if (Array.isArray(n[r]))
      throw new k(
        `Query keys must be strings, but found key of type: ${typeof r}`,
        r
      );
    if (typeof r != "string")
      throw new k(
        `Query keys must be strings, but found key of type: ${typeof r}`,
        r
      );
    if (r !== "$$ruleParams") {
      if (e && !e.entities[r]) {
        const s = Object.keys(e.entities);
        throw new k(
          `Entity '${r}' does not exist in schema. Available entities: ${s.length > 0 ? s.join(", ") : "none"}`,
          r
        );
      }
      Fn(
        t[r],
        r,
        e,
        r,
        0
        // Start at depth 0 for top-level entities
      );
    }
  }
}, Gt = (n) => typeof n != "string" ? !1 : Ce(n) ? !0 : re(n);
class q extends Error {
  constructor(e) {
    super(e), this.name = "TransactionValidationError";
  }
}
const qn = (n) => n.length > 0 ? n.join(", ") : "none", Ui = (n, e) => new q(
  `Entity '${n}' does not exist in schema. Available entities: ${qn(e)}`
), Le = {
  string: (n) => typeof n == "string",
  number: (n) => typeof n == "number" && !isNaN(n),
  boolean: (n) => typeof n == "boolean",
  date: (n) => n instanceof Date || typeof n == "string" || typeof n == "number",
  json: () => !0
}, Li = (n, e) => {
  var t;
  return n == null ? !0 : ((t = Le[e.valueType]) == null ? void 0 : t.call(Le, n)) ?? !1;
}, Kn = (n, e) => {
  const t = e.entities[n];
  if (!t)
    throw Ui(n, Object.keys(e.entities));
  return t;
}, Ne = (n, e, t) => {
  const r = Kn(n, t);
  if (typeof e != "object" || e === null)
    throw new q(
      `Arguments for data operation on entity '${n}' must be an object, but received: ${typeof e}`
    );
  for (const [s, i] of Object.entries(e)) {
    if (s === "id") continue;
    const o = r.attrs[s];
    if (o && !Li(i, o))
      throw new q(
        `Invalid value for attribute '${s}' in entity '${n}'. Expected ${o.valueType}, but received: ${typeof i}`
      );
  }
}, Bt = (n, e, t) => {
  const r = Kn(n, t);
  if (typeof e != "object" || e === null)
    throw new q(
      `Arguments for link operation on entity '${n}' must be an object, but received: ${typeof e}`
    );
  for (const [s, i] of Object.entries(e)) {
    if (!r.links[s]) {
      const a = Object.keys(r.links);
      throw new q(
        `Link '${s}' does not exist on entity '${n}'. Available links: ${qn(a)}`
      );
    }
    if (i != null) {
      if (Array.isArray(i)) {
        for (const a of i)
          if (!Gt(a))
            throw new q(
              `Invalid entity ID in link '${s}' for entity '${n}'. Expected a UUID or a lookup, but received: ${a}`
            );
      } else if (!Gt(i))
        throw new q(
          `Invalid UUID in link '${s}' for entity '${n}'. Expected a UUID, but received: ${i}`
        );
    }
  }
}, Ni = {
  create: Ne,
  update: Ne,
  merge: Ne,
  link: Bt,
  unlink: Bt,
  delete: () => {
  }
}, Fi = (n, e) => {
  if (!e) return;
  const [t, r, s, i] = n;
  if (!Array.isArray(s) && !re(s))
    throw new q(
      `Invalid id for entity '${r}'. Expected a UUID, but received: ${s}`
    );
  if (typeof r != "string")
    throw new q(
      `Entity name must be a string, but received: ${typeof r}`
    );
  const o = Ni[t];
  o && i !== void 0 && o(r, i, e);
}, qi = (n, e) => {
  const t = Array.isArray(n) ? n : [n];
  for (const r of t) {
    if (!r || typeof r != "object")
      throw new q(
        `Transaction chunk must be an object, but received: ${typeof r}`
      );
    if (!Array.isArray(r.__ops))
      throw new q(
        `Transaction chunk must have __ops array, but received: ${typeof r.__ops}`
      );
    for (const s of r.__ops) {
      if (!Array.isArray(s))
        throw new q(
          `Transaction operation must be an array, but received: ${typeof s}`
        );
      Fi(s, e);
    }
  }
};
let zn = 0;
class Ht {
  constructor(e) {
    this.type = "ws", this.id = `${this.type}_${zn++}`, this.conn = new WebSocket(e), this.conn.onopen = (t) => {
      this.onopen && this.onopen({ target: this });
    }, this.conn.onmessage = (t) => {
      this.onmessage && this.onmessage({
        target: this,
        message: JSON.parse(t.data.toString())
      });
    }, this.conn.onclose = (t) => {
      this.onclose && this.onclose({ target: this });
    }, this.conn.onerror = (t) => {
      this.onerror && this.onerror({ target: this });
    };
  }
  close() {
    this.conn.close();
  }
  isOpen() {
    return this.conn.readyState === (WebSocket.OPEN ?? 1);
  }
  isConnecting() {
    return this.conn.readyState === (WebSocket.CONNECTING ?? 0);
  }
  send(e) {
    return this.conn.send(JSON.stringify(e));
  }
}
class Ki {
  constructor(e, t) {
    this.type = "sse", this.initParams = null, this.sendQueue = [], this.closeFired = !1, this.sseInitTimeout = void 0, this.id = `${this.type}_${zn++}`, this.url = t, this.ES = e, this.conn = new e(t), this.sseInitTimeout = setTimeout(() => {
      this.initParams || this.handleError();
    }, 1e4), this.conn.onmessage = (r) => {
      const s = JSON.parse(r.data);
      if (Array.isArray(s))
        for (const i of s)
          this.handleMessage(i);
      else
        this.handleMessage(s);
    }, this.conn.onerror = (r) => {
      this.handleError();
    };
  }
  handleMessage(e) {
    if (e.op === "sse-init") {
      this.initParams = {
        machineId: e["machine-id"],
        sessionId: e["session-id"],
        sseToken: e["sse-token"]
      }, this.onopen && this.onopen({ target: this }), clearTimeout(this.sseInitTimeout);
      return;
    }
    this.onmessage && this.onmessage({
      target: this,
      message: e
    });
  }
  // Runs the onerror and closes the connection
  handleError() {
    try {
      this.onerror && this.onerror({ target: this });
    } finally {
      this.handleClose();
    }
  }
  handleClose() {
    this.conn.close(), this.onclose && !this.closeFired && (this.closeFired = !0, this.onclose({ target: this }));
  }
  async postMessages(e) {
    var t, r, s;
    try {
      (await fetch(this.url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          machine_id: (t = this.initParams) == null ? void 0 : t.machineId,
          session_id: (r = this.initParams) == null ? void 0 : r.sessionId,
          sse_token: (s = this.initParams) == null ? void 0 : s.sseToken,
          messages: e
        })
      })).ok || this.handleError();
    } catch {
      this.handleError();
    }
  }
  async flushQueue() {
    if (this.sendPromise || !this.sendQueue.length) return;
    const e = this.sendQueue;
    this.sendQueue = [];
    const t = this.postMessages(e);
    this.sendPromise = t, t.then(() => {
      this.sendPromise = null, this.flushQueue();
    });
  }
  send(e) {
    if (!this.isOpen() || !this.initParams)
      throw this.isConnecting() ? new Error(
        "Failed to execute 'send' on 'EventSource': Still in CONNECTING state."
      ) : this.conn.readyState === this.ES.CLOSED ? new Error("EventSource is already in CLOSING or CLOSED state.") : new Error("EventSource is in invalid state.");
    this.sendQueue.push(e), this.flushQueue();
  }
  isOpen() {
    return this.conn.readyState === this.ES.OPEN && this.initParams !== null;
  }
  isConnecting() {
    return this.conn.readyState === this.ES.CONNECTING || this.conn.readyState === this.ES.OPEN && this.initParams === null;
  }
  close() {
    this.handleClose();
  }
}
function zi(n, e) {
  const t = n.values;
  if (t) {
    const r = bn(t.attrsStore, null);
    if (r) {
      for (const s of t.entities || [])
        s.store.useDateObjects = e, s.store = yn(r, s.store);
      t.attrsStore = r;
    }
  }
  return n;
}
function Vi(n, e) {
  var t;
  if (e.values) {
    const r = [];
    for (const s of (t = e.values) == null ? void 0 : t.entities) {
      const i = pn(s.store);
      r.push({ ...s, store: i });
    }
    return {
      ...e,
      values: { attrsStore: e.values.attrsStore.toJSON(), entities: r }
    };
  } else
    return e;
}
function Qi(n, e, t) {
  var i, o;
  const r = (i = e == null ? void 0 : e.state) == null ? void 0 : i.txId, s = (o = t == null ? void 0 : t.state) == null ? void 0 : o.txId;
  return r && (!s || r > s) ? e : s && (!r || s > r) ? t : e || t;
}
function Fe(n, e, t) {
  return gt(
    { store: e, attrsStore: t, pageInfo: null, aggregate: null },
    n.query
  ).data[n.table][0];
}
function Jt(n, e, t, r) {
  var o;
  const s = (o = C(t, n.table, "id")) == null ? void 0 : o.id;
  if (!s)
    return -1;
  const i = ie(e.eav, [r, s, r]);
  return i ? i[3] : -1;
}
function Yt(n, e, t) {
  for (const { action: r, triple: s } of t)
    switch (r) {
      case "added":
        wn(n, e, s);
        break;
      case "removed":
        gn(n, e, s);
        break;
    }
}
function Wi(n, e, t) {
  var s, i;
  const r = {};
  for (const { action: o, triple: a } of t) {
    const [c, u, l] = a, f = (i = (s = e.getAttr(u)) == null ? void 0 : s["forward-identity"]) == null ? void 0 : i[2];
    if (!f) continue;
    const d = r[c] ?? {};
    r[c] = d;
    const h = d[f] ?? {};
    switch (o) {
      case "added":
        h.newValue = l;
        break;
      case "removed":
        h.oldValue === void 0 && (h.oldValue = l);
        break;
    }
    d[f] = h;
  }
  for (const [o, a] of Object.entries(r))
    for (const [c, { oldValue: u, newValue: l }] of Object.entries(a))
      u === l && delete a[c];
  return r;
}
function we(n, e) {
  return { [n.table]: e.map((t) => t.entity) };
}
function Gi(n, e) {
  var r;
  if (n.orderFieldType)
    return n.orderFieldType;
  const t = n.orderField === "serverCreatedAt" ? "number" : (r = C(e(), n.table, n.orderField)) == null ? void 0 : r["checked-data-type"];
  return n.orderFieldType = t, t;
}
function Bi(n, e, t) {
  const r = e;
  if (n.orderField === "serverCreatedAt") {
    t.sort(
      n.orderDirection === "asc" ? function(o, a) {
        return ue(
          o.entity.id,
          o.serverCreatedAt,
          a.entity.id,
          a.serverCreatedAt,
          r
        );
      } : function(o, a) {
        return ue(
          a.entity.id,
          a.serverCreatedAt,
          o.entity.id,
          o.serverCreatedAt,
          r
        );
      }
    );
    return;
  }
  const s = n.orderField;
  t.sort(
    n.orderDirection === "asc" ? function(o, a) {
      return ue(
        o.entity.id,
        o.entity[s],
        a.entity.id,
        a.entity[s],
        r
      );
    } : function(o, a) {
      return ue(
        a.entity.id,
        a.entity[s],
        o.entity.id,
        o.entity[s],
        r
      );
    }
  );
}
var Hi = /* @__PURE__ */ ((n) => (n.InitialSyncBatch = "InitialSyncBatch", n.InitialSyncComplete = "InitialSyncComplete", n.LoadFromStorage = "LoadFromStorage", n.SyncTransaction = "SyncTransaction", n.Error = "Error", n))(Hi || {});
class Ji {
  constructor(e, t, r, s, i, o) {
    this.callbacks = {}, this.idToHash = {}, this.trySend = e, this.config = r, this.log = s, this.createStore = i, this.getAttrs = o, this.subs = new nt({
      persister: t,
      merge: Qi,
      serialize: Vi,
      parse: (a, c) => zi(c, this.config.useDateObjects),
      objectSize: (a) => {
        var c;
        return ((c = a.values) == null ? void 0 : c.entities.length) || 0;
      },
      logger: s,
      gc: {
        maxAgeMs: 1e3 * 60 * 60 * 24 * 7 * 52,
        // 1 year
        maxEntries: 1e3,
        // Size of each sub is the number of entity
        maxSize: 1e6
        // 1 million entities
      }
    });
  }
  beforeUnload() {
    this.subs.flush();
  }
  subscribe(e, t) {
    const r = M(e);
    return this.callbacks[r] = this.callbacks[r] || [], this.callbacks[r].push(t), this.initSubscription(e, r, t), (s) => {
      this.unsubscribe(r, t, s == null ? void 0 : s.keepSubscription);
    };
  }
  unsubscribe(e, t, r) {
    const s = (this.callbacks[e] || []).filter((i) => i !== t);
    if (this.callbacks[e] = s, !s.length) {
      delete this.callbacks[e];
      const i = this.subs.currentValue[e];
      i != null && i.state && this.clearSubscriptionData(
        i.state.subscriptionId,
        !!r
      ), r || this.subs.updateInPlace((o) => {
        delete o[e];
      });
    }
  }
  sendStart(e) {
    this.trySend(P(), {
      op: "start-sync",
      q: e
    });
  }
  sendResync(e, t, r) {
    this.idToHash[t.subscriptionId] = e.hash, this.trySend(t.subscriptionId, {
      op: "resync-table",
      "subscription-id": t.subscriptionId,
      "tx-id": r,
      token: t.token
    });
  }
  sendRemove(e, t) {
    this.trySend(P(), {
      op: "remove-sync",
      "subscription-id": e.subscriptionId,
      "keep-subscription": t
    });
  }
  async initSubscription(e, t, r) {
    var u, l, f, d;
    await this.subs.waitForKeyToLoad(t);
    const s = this.subs.currentValue[t];
    if (s && s.state && s.state.txId) {
      this.sendResync(s, s.state, s.state.txId), (u = s.values) != null && u.entities && r && r({
        type: "LoadFromStorage",
        data: we(s, (l = s.values) == null ? void 0 : l.entities)
      });
      return;
    }
    const i = Object.keys(e)[0], o = ((d = (f = e[i]) == null ? void 0 : f.$) == null ? void 0 : d.order) || { serverCreatedAt: "asc" }, [a, c] = Object.entries(o)[0];
    this.subs.updateInPlace((h) => {
      h[t] = {
        query: e,
        hash: t,
        table: i,
        orderDirection: c,
        orderField: a,
        createdAt: Date.now(),
        updatedAt: Date.now()
      };
    }), this.sendStart(e);
  }
  async flushPending() {
    for (const e of Object.keys(this.callbacks)) {
      await this.subs.waitForKeyToLoad(e);
      const t = this.subs.currentValue[e];
      t ? await this.initSubscription(t.query, t.hash) : this.log.error("Missing sub for hash in flushPending", e);
    }
  }
  onStartSyncOk(e) {
    const t = e["subscription-id"], r = e.q, s = M(r);
    this.idToHash[t] = s, this.subs.updateInPlace((i) => {
      const o = i[s];
      if (!o)
        return this.log.error(
          "Missing sub for hash",
          s,
          "subscription-id",
          t,
          "query",
          r
        ), i;
      o.state = {
        subscriptionId: t,
        token: e.token
      };
    });
  }
  notifyCbs(e, t) {
    for (const r of this.callbacks[e] || [])
      r(t);
  }
  onSyncLoadBatch(e) {
    const t = e["subscription-id"], r = e["join-rows"], s = this.idToHash[t];
    if (!s) {
      this.log.error("Missing hash for subscription", e);
      return;
    }
    const i = [], o = this.subs.currentValue[s];
    if (!o) {
      this.log.error("Missing sub for hash", s, e);
      return;
    }
    const a = o.values ?? {
      entities: [],
      attrsStore: this.getAttrs()
    };
    o.values = a;
    const c = a.entities;
    for (const u of r) {
      const l = this.createStore(u), f = Fe(o, l, a.attrsStore);
      c.push({
        store: l,
        entity: f,
        serverCreatedAt: Jt(
          o,
          l,
          a.attrsStore,
          f.id
        )
      }), i.push(f);
    }
    this.subs.updateInPlace((u) => {
      u[s] = o, u[s].updatedAt = Date.now();
    }), o.values && this.notifyCbs(s, {
      type: "InitialSyncBatch",
      data: we(o, o.values.entities),
      batch: i
    });
  }
  onSyncInitFinish(e) {
    var i;
    const t = e["subscription-id"], r = this.idToHash[t];
    if (!r) {
      this.log.error("Missing hash for subscription", e);
      return;
    }
    this.subs.updateInPlace((o) => {
      const a = o[r];
      if (!a) {
        this.log.error("Missing sub for hash", r, e);
        return;
      }
      const c = a.state;
      if (!c)
        return this.log.error("Sub never set init, missing result", a, e), o;
      c.txId = e["tx-id"], a.updatedAt = Date.now();
    });
    const s = this.subs.currentValue[r];
    s && this.notifyCbs(r, {
      type: "InitialSyncComplete",
      data: we(s, ((i = s.values) == null ? void 0 : i.entities) || [])
    });
  }
  onSyncUpdateTriples(e) {
    var o;
    const t = e["subscription-id"], r = this.idToHash[t];
    if (!r) {
      this.log.error("Missing hash for subscription", e);
      return;
    }
    const s = this.subs.currentValue[r];
    if (!s) {
      this.log.error("Missing sub for hash", r, e);
      return;
    }
    const i = s.state;
    if (!i) {
      this.log.error("Missing state for sub", s, e);
      return;
    }
    for (const a of e.txes) {
      if (i.txId && i.txId >= a["tx-id"])
        continue;
      i.txId = a["tx-id"];
      const c = [], u = {};
      for (const _ of a.changes) {
        const g = u[_.triple[0]] ?? [];
        u[_.triple[0]] = g, g.push(_);
      }
      const l = s.values ?? {
        entities: [],
        attrsStore: this.getAttrs()
      }, f = l.entities;
      s.values = l;
      const d = [];
      e: for (const [_, g] of Object.entries(u))
        for (let y = 0; y < f.length; y++) {
          const w = f[y];
          if (Cr(w.store, _)) {
            Yt(w.store, l.attrsStore, g);
            const S = Fe(s, w.store, l.attrsStore), m = Wi(
              w.store,
              l.attrsStore,
              g
            )[_];
            S ? (d.push({
              oldEntity: w.entity,
              newEntity: S,
              changedFields: m || {}
            }), w.entity = S) : c.push(y), delete u[_];
            continue e;
          }
        }
      const h = [];
      for (const [_, g] of Object.entries(u)) {
        const y = this.createStore([]);
        Yt(y, l.attrsStore, g);
        const w = Fe(s, y, l.attrsStore);
        if (!w) {
          this.log.error("No entity found after applying change", {
            sub: s,
            changes: g,
            store: y
          });
          continue;
        }
        f.push({
          store: y,
          entity: w,
          serverCreatedAt: Jt(
            s,
            y,
            l.attrsStore,
            w.id
          )
        }), h.push(w);
      }
      const p = [];
      for (const _ of c.sort().reverse())
        p.push(f[_].entity), f.splice(_, 1);
      const b = Gi(s, this.getAttrs);
      Bi(s, b, f), this.notifyCbs(r, {
        type: "SyncTransaction",
        data: we(s, (o = s.values) == null ? void 0 : o.entities),
        added: h,
        removed: p,
        updated: d
      });
    }
    this.subs.updateInPlace((a) => {
      a[r] = s, a[r].updatedAt = Date.now();
    });
  }
  clearSubscriptionData(e, t) {
    const r = this.idToHash[e];
    if (r) {
      delete this.idToHash[e];
      const s = this.subs.currentValue[r];
      if (s.state && this.sendRemove(s.state, t), t ? this.subs.unloadKey(r) : this.subs.updateInPlace((i) => {
        delete i[r];
      }), s)
        return s;
    }
  }
  onStartSyncError(e) {
    const t = M(e["original-event"].q), r = {
      message: e.message || "Uh-oh, something went wrong. Ping Joe & Stopa.",
      status: e.status,
      type: e.type,
      hint: e.hint
    }, s = Object.keys(e["original-event"].q)[0];
    this.notifyCbs(t, {
      type: "Error",
      data: { [s]: [] },
      error: r
    });
  }
  onResyncError(e) {
    const t = e["original-event"]["subscription-id"], r = this.clearSubscriptionData(t, !1);
    r && this.initSubscription(r.query, r.hash);
  }
}
const W = {
  CONNECTING: "connecting",
  OPENED: "opened",
  AUTHENTICATED: "authenticated",
  CLOSED: "closed",
  ERRORED: "errored"
}, Yi = 3e4, Zi = 3e4, Xi = 200, eo = 1e3 * 60, to = {
  apiURI: "https://api.instantdb.com",
  websocketURI: "wss://api.instantdb.com/runtime/session"
}, qe = "_instant_oauth_redirect", oe = "currentUser";
function no({
  transportType: n,
  appId: e,
  apiURI: t,
  wsURI: r,
  EventSourceImpl: s
}) {
  if (!s)
    return new Ht(`${r}?app_id=${e}`);
  switch (n) {
    case "ws":
      return new Ht(`${r}?app_id=${e}`);
    case "sse":
      return new Ki(
        s,
        `${t}/runtime/sse?app_id=${e}`
      );
    default:
      throw new Error("Unknown transport type " + n);
  }
}
function ro() {
  return typeof window < "u" || typeof chrome < "u";
}
const Zt = {
  "set-presence": !0,
  "set-presence-ok": !0,
  "refresh-presence": !0,
  "patch-presence": !0
};
function so(n, e) {
  var r;
  const t = typeof n == "string" ? JSON.parse(n) : n;
  if ((r = t == null ? void 0 : t.result) != null && r.store) {
    const s = bn(
      t.result.attrsStore,
      t.result.store
    );
    if (s) {
      const i = t.result.store;
      t.result.store = yn(s, {
        ...i,
        useDateObjects: e
      }), t.result.attrsStore = s;
    }
  }
  return t;
}
function io(n, e) {
  const { result: t, ...r } = e, s = (
    /** @type {import('./reactorTypes.ts').QuerySubInStorage} */
    r
  );
  if (t) {
    const i = {
      ...t,
      store: pn(t.store),
      attrsStore: t.attrsStore.toJSON()
    };
    s.result = i;
  }
  return s;
}
function oo(n, e) {
  switch (n) {
    case "pendingMutations":
      return new Map(typeof e == "string" ? JSON.parse(e) : e);
    default:
      return e;
  }
}
function ao(n, e) {
  switch (n) {
    case "pendingMutations":
      return [...e.entries()];
    default:
      return e;
  }
}
function co(n, e, t) {
  const r = e == null ? void 0 : e.result, s = t == null ? void 0 : t.result;
  return r && !s && t && (t.result = r), t || e;
}
function Xt(n) {
  return [...n].sort((e, t) => {
    const [r, s] = e, [i, o] = t, a = s.order || 0, c = o.order || 0;
    return a == c ? r < i ? -1 : r > i ? 1 : 0 : a - c;
  });
}
class uo {
  constructor(e, t = jn, r = $n, s, i) {
    /** @type {s.AttrsStore | undefined} */
    T(this, "attrs");
    T(this, "_isOnline", !0);
    T(this, "_isShutdown", !1);
    T(this, "status", W.CONNECTING);
    /** @type {PersistedObject<string, QuerySub, QuerySubInStorage>} */
    T(this, "querySubs");
    /** @type {PersistedObject} */
    T(this, "kv");
    /** @type {SyncTable} */
    T(this, "_syncTable");
    /** @type {Record<string, Array<{ q: any, cb: (data: any) => any }>>} */
    T(this, "queryCbs", {});
    /** @type {Record<string, Array<{ q: any, eventId: string, dfd: Deferred }>>} */
    T(this, "queryOnceDfds", {});
    T(this, "authCbs", []);
    T(this, "attrsCbs", []);
    T(this, "mutationErrorCbs", []);
    T(this, "connectionStatusCbs", []);
    T(this, "config");
    T(this, "mutationDeferredStore", /* @__PURE__ */ new Map());
    T(this, "_reconnectTimeoutId", null);
    T(this, "_reconnectTimeoutMs", 0);
    /** @type {Connection} */
    T(this, "_transport");
    /** @type {TransportType} */
    T(this, "_transportType", "ws");
    /** @type {EventSourceConstructor} */
    T(this, "_EventSource");
    /** @type {boolean | null} */
    T(this, "_wsOk", null);
    T(this, "_localIdPromises", {});
    T(this, "_errorMessage", null);
    /** @type {Promise<null | {error: {message: string}}> | null}**/
    T(this, "_oauthCallbackResponse", null);
    /** @type {null | import('./utils/linkIndex.ts').LinkIndex}} */
    T(this, "_linkIndex", null);
    /** @type BroadcastChannel | undefined */
    T(this, "_broadcastChannel");
    /** @type {Record<string, {isConnected: boolean; error: any}>} */
    T(this, "_rooms", {});
    /** @type {Record<string, boolean>} */
    T(this, "_roomsPendingLeave", {});
    T(this, "_presence", {});
    T(this, "_broadcastQueue", []);
    T(this, "_broadcastSubs", {});
    /** @type {{isLoading: boolean; error: any | undefined, user: any | undefined}} */
    T(this, "_currentUserCached", { isLoading: !0, error: void 0, user: void 0 });
    T(this, "_beforeUnloadCbs", []);
    T(this, "_dataForQueryCache", {});
    /** @type {Logger} */
    T(this, "_log");
    T(this, "_pendingTxCleanupTimeout");
    T(this, "_pendingMutationCleanupThreshold");
    T(this, "_inFlightMutationEventIds", /* @__PURE__ */ new Set());
    T(this, "_onMergeKv", (e, t, r) => {
      switch (e) {
        case "pendingMutations": {
          const s = (t == null ? void 0 : t.entries()) ?? [], i = (r == null ? void 0 : r.entries()) ?? [], o = new Map([...s, ...i]);
          return (t ? this._rewriteMutationsSorted(this.attrs, t) : []).forEach(([c, u]) => {
            var l;
            !((l = r == null ? void 0 : r.pendingMutations) != null && l.has(c)) && !u["tx-id"] && this._sendMutation(c, u);
          }), o;
        }
        default:
          return r || t;
      }
    });
    // ---------------------------
    // Queries
    T(this, "getPreviousResult", (e) => {
      var r;
      const t = M(e);
      return (r = this.dataForQuery(t)) == null ? void 0 : r.data;
    });
    /** Re-run instaql and call all callbacks with new data */
    T(this, "notifyOne", (e) => {
      var i;
      const t = this.queryCbs[e] ?? [], r = (i = this._dataForQueryCache[e]) == null ? void 0 : i.data, s = this.dataForQuery(e);
      s != null && s.data && (this._dataForQueryCache[e] = s, !Oe(s.data, r) && t.forEach((o) => o.cb(s.data)));
    });
    T(this, "notifyOneQueryOnce", (e) => {
      var s;
      const t = this.queryOnceDfds[e] ?? [], r = (s = this.dataForQuery(e)) == null ? void 0 : s.data;
      t.forEach((i) => {
        this._completeQueryOnce(i.q, e, i.dfd), i.dfd.resolve(r);
      });
    });
    T(this, "notifyQueryError", (e, t) => {
      (this.queryCbs[e] || []).forEach((s) => s.cb({ error: t }));
    });
    /** Applies transactions locally and sends transact message to server */
    T(this, "pushTx", (e) => {
      this.config.disableValidation || qi(e, this.config.schema);
      try {
        const t = fi(
          {
            attrsStore: this.optimisticAttrs(),
            schema: this.config.schema,
            stores: Object.values(this.querySubs.currentValue).map(
              (r) => {
                var s;
                return (s = r == null ? void 0 : r.result) == null ? void 0 : s.store;
              }
            ),
            useDateObjects: this.config.useDateObjects
          },
          e
        );
        return this.pushOps(t);
      } catch (t) {
        return this.pushOps([], t);
      }
    });
    /**
     * @param {*} txSteps
     * @param {*} [error]
     * @returns
     */
    T(this, "pushOps", (e, t) => {
      const r = P(), s = [...this._pendingMutations().values()], i = Math.max(0, ...s.map((c) => c.order || 0)) + 1, o = {
        op: "transact",
        "tx-steps": e,
        created: Date.now(),
        error: t,
        order: i
      };
      this._updatePendingMutations((c) => {
        c.set(r, o);
      });
      const a = new zt();
      return this.mutationDeferredStore.set(r, a), this._sendMutation(r, o), this.notifyAll(), a.promise;
    });
    T(this, "_transportOnOpen", (e) => {
      const t = e.target;
      if (this._transport !== t) {
        this._log.info(
          "[socket][open]",
          t.id,
          "skip; this is no longer the current transport"
        );
        return;
      }
      this._log.info("[socket][open]", this._transport.id), this._setStatus(W.OPENED), this.getCurrentUser().then((r) => {
        var s;
        this._trySend(P(), {
          op: "init",
          "app-id": this.config.appId,
          "refresh-token": (s = r.user) == null ? void 0 : s.refresh_token,
          versions: this.versions,
          // If an admin token is provided for an app, we will
          // skip all permission checks. This is an advanced feature,
          // to let users write internal tools
          // This option is not exposed in `Config`, as it's
          // not ready for prime time
          "__admin-token": this.config.__adminToken
        });
      }).catch((r) => {
        this._log.error("[socket][error]", t.id, r);
      });
    });
    T(this, "_transportOnMessage", (e) => {
      const t = e.target, r = e.message;
      if (this._transport !== t) {
        this._log.info(
          "[socket][message]",
          t.id,
          r,
          "skip; this is no longer the current transport"
        );
        return;
      }
      if (!this._wsOk && t.type === "ws" && (this._wsOk = !0), this._transportType = "ws", Array.isArray(e.message))
        for (const s of e.message)
          this._handleReceive(t.id, s);
      else
        this._handleReceive(t.id, e.message);
    });
    T(this, "_transportOnError", (e) => {
      const t = e.target;
      if (this._transport !== t) {
        this._log.info(
          "[socket][error]",
          t.id,
          "skip; this is no longer the current transport"
        );
        return;
      }
      this._log.error("[socket][error]", t.id, e);
    });
    T(this, "_scheduleReconnect", () => {
      !this._wsOk && this._transportType !== "sse" && (this._transportType = "sse", this._reconnectTimeoutMs = 0), setTimeout(() => {
        if (this._reconnectTimeoutMs = Math.min(
          this._reconnectTimeoutMs + 1e3,
          1e4
        ), !this._isOnline) {
          this._log.info(
            "[socket][close]",
            this._transport.id,
            "we are offline, no need to start socket"
          );
          return;
        }
        this._startSocket();
      }, this._reconnectTimeoutMs);
    });
    T(this, "_transportOnClose", (e) => {
      const t = e.target;
      if (this._transport !== t) {
        this._log.info(
          "[socket][close]",
          t.id,
          "skip; this is no longer the current transport"
        );
        return;
      }
      this._setStatus(W.CLOSED);
      for (const r of Object.values(this._rooms))
        r.isConnected = !1;
      if (this._isShutdown) {
        this._log.info(
          "[socket][close]",
          t.id,
          "Reactor has been shut down and will not reconnect"
        );
        return;
      }
      this._log.info(
        "[socket][close]",
        t.id,
        "schedule reconnect, ms =",
        this._reconnectTimeoutMs
      ), this._scheduleReconnect();
    });
    if (this._EventSource = i, this.config = { ...to, ...e }, this.queryCacheLimit = this.config.queryCacheLimit ?? 10, this._pendingTxCleanupTimeout = this.config.pendingTxCleanupTimeout ?? Zi, this._pendingMutationCleanupThreshold = this.config.pendingMutationCleanupThreshold ?? Xi, this._log = ji(
      e.verbose || _t || Dn,
      () => this._reactorStats()
    ), this.versions = { ...s || {}, "@instantdb/core": Un }, this.config.schema && (this._linkIndex = rt(this.config.schema)), !!ro()) {
      if (!e.appId)
        throw new Error("Instant must be initialized with an appId.");
      if (!re(e.appId))
        throw new Error(
          `Instant must be initialized with a valid appId. \`${e.appId}\` is not a valid uuid.`
        );
      typeof BroadcastChannel == "function" && (this._broadcastChannel = new BroadcastChannel("@instantdb"), this._broadcastChannel.addEventListener("message", async (o) => {
        var a;
        try {
          if (((a = o.data) == null ? void 0 : a.type) === "auth") {
            const c = await this.getCurrentUser();
            this.updateUser(c.user);
          }
        } catch (c) {
          this._log.error("[error] handle broadcast channel", c);
        }
      })), this._initStorage(t), this._syncTable = new Ji(
        this._trySendAuthed.bind(this),
        new t(this.config.appId, "syncSubs"),
        {
          useDateObjects: this.config.useDateObjects
        },
        this._log,
        (o) => te(
          this.ensureAttrs(),
          o,
          this.config.enableCardinalityInference,
          this.config.useDateObjects
        ),
        () => this.ensureAttrs()
      ), this._oauthCallbackResponse = this._oauthLoginInit(), this.getCurrentUser().then((o) => {
        this.syncUserToEndpoint(o.user);
      }), setInterval(async () => {
        const o = await this.getCurrentUser();
        this.syncUserToEndpoint(o.user);
      }, eo), r.getIsOnline().then((o) => {
        this._isOnline = o, this._startSocket(), r.listen((a) => {
          a !== this._isOnline && (this._log.info("[network] online =", a), this._isOnline = a, this._isOnline ? this._startSocket() : (this._log.info(
            "Changing status from",
            this.status,
            "to",
            W.CLOSED
          ), this._setStatus(W.CLOSED)));
        });
      }), typeof addEventListener < "u" && (this._beforeUnload = this._beforeUnload.bind(this), addEventListener("beforeunload", this._beforeUnload));
    }
  }
  ensureAttrs() {
    if (!this.attrs)
      throw new Error("attrs have not loaded.");
    return this.attrs;
  }
  updateSchema(e) {
    this.config = {
      ...this.config,
      schema: e,
      cardinalityInference: !!e
    }, this._linkIndex = e ? rt(this.config.schema) : null;
  }
  _reactorStats() {
    return {
      inFlightMutationCount: this._inFlightMutationEventIds.size,
      storedMutationCount: this._pendingMutations().size,
      transportType: this._transportType
    };
  }
  _onQuerySubLoaded(e) {
    this.kv.waitForKeyToLoad("pendingMutations").then(() => this.notifyOne(e));
  }
  _initStorage(e) {
    this.querySubs = new nt({
      persister: new e(this.config.appId, "querySubs"),
      merge: co,
      serialize: io,
      parse: (t, r) => so(r, this.config.useDateObjects),
      // objectSize
      objectSize: (t) => {
        var r, s, i;
        return ((i = (s = (r = t == null ? void 0 : t.result) == null ? void 0 : r.store) == null ? void 0 : s.triples) == null ? void 0 : i.length) ?? 0;
      },
      logger: this._log,
      preloadEntryCount: 10,
      gc: {
        maxAgeMs: 1e3 * 60 * 60 * 24 * 7 * 52,
        // 1 year
        maxEntries: 1e3,
        // Size of each query is the number of triples
        maxSize: 1e6
        // 1 million triples
      }
    }), this.querySubs.onKeyLoaded = (t) => this._onQuerySubLoaded(t), this.kv = new nt({
      persister: new e(this.config.appId, "kv"),
      merge: this._onMergeKv,
      serialize: ao,
      parse: oo,
      objectSize: () => 0,
      logger: this._log,
      saveThrottleMs: 100,
      idleCallbackMaxWaitMs: 100,
      // Don't GC the kv store
      gc: null
    }), this.kv.onKeyLoaded = (t) => {
      t === "pendingMutations" && this.notifyAll();
    }, this.kv.waitForKeyToLoad("pendingMutations"), this.kv.waitForKeyToLoad(oe), this._beforeUnloadCbs.push(() => {
      this.kv.flush(), this.querySubs.flush();
    });
  }
  _beforeUnload() {
    for (const e of this._beforeUnloadCbs)
      e();
    this._syncTable.beforeUnload();
  }
  /**
   * @param {'enqueued' | 'pending' | 'synced' | 'timeout' |  'error' } status
   * @param {string} eventId
   * @param {{message?: string, type?: string, status?: number, hint?: unknown}} [errorMsg]
   */
  _finishTransaction(e, t, r) {
    const s = this.mutationDeferredStore.get(t);
    this.mutationDeferredStore.delete(t);
    const i = e !== "error" && e !== "timeout";
    if (!s && !i && console.error("Mutation failed", { status: e, eventId: t, ...r }), !!s)
      if (i)
        s.resolve({ status: e, eventId: t });
      else if (r != null && r.type) {
        const { status: o, ...a } = r;
        s.reject(
          new je({
            // @ts-expect-error body.type is not constant typed
            body: a,
            status: o ?? 0
          })
        );
      } else
        s.reject(
          new pe(
            (r == null ? void 0 : r.message) || "Unknown error",
            r == null ? void 0 : r.hint
          )
        );
  }
  _setStatus(e, t) {
    this.status = e, this._errorMessage = t, this.notifyConnectionStatusSubs(e);
  }
  _flushEnqueuedRoomData(e) {
    var s, i;
    const t = (i = (s = this._presence[e]) == null ? void 0 : s.result) == null ? void 0 : i.user, r = this._broadcastQueue[e];
    if (this._broadcastQueue[e] = [], t && this._trySetPresence(e, t), r)
      for (const o of r) {
        const { topic: a, roomType: c, data: u } = o;
        this._tryBroadcast(e, c, a, u);
      }
  }
  /**
   * Does the same thing as add-query-ok
   * but called as a result of receiving query info from ssr
   * @param {any} q
   * @param {{ triples: any; pageInfo: any; }} result
   * @param {boolean} enableCardinalityInference
   */
  _addQueryData(e, t, r) {
    if (!this.attrs)
      throw new Error("Attrs in reactor have not been set");
    const s = M(e), i = this.ensureAttrs(), o = te(
      this.attrs,
      t.triples,
      r,
      this.config.useDateObjects
    );
    this.querySubs.updateInPlace((a) => {
      a[s] = {
        result: {
          store: o,
          attrsStore: i,
          pageInfo: t.pageInfo,
          processedTxId: void 0,
          isExternal: !0
        },
        q: e
      };
    }), this._cleanupPendingMutationsQueries(), this.notifyOne(s), this.notifyOneQueryOnce(s), this._cleanupPendingMutationsTimeout();
  }
  _handleReceive(e, t) {
    var s, i, o, a, c, u;
    const r = !!this.config.schema && ("cardinalityInference" in this.config ? !!this.config.cardinalityInference : !0);
    switch (Zt[t.op] || this._log.info("[receive]", e, t.op, t), t.op) {
      case "init-ok": {
        this._setStatus(W.AUTHENTICATED), this._reconnectTimeoutMs = 0, this._setAttrs(t.attrs), this._flushPendingMessages(), this._sessionId = t["session-id"];
        for (const d of Object.keys(this._rooms)) {
          const h = (i = (s = this._presence[d]) == null ? void 0 : s.result) == null ? void 0 : i.user;
          this._tryJoinRoom(d, h);
        }
        break;
      }
      case "add-query-exists": {
        this.notifyOneQueryOnce(M(t.q));
        break;
      }
      case "add-query-ok": {
        const { q: d, result: h } = t, p = M(d);
        if (!this._hasQueryListeners() && !this.querySubs.currentValue[p])
          break;
        const b = (a = (o = h == null ? void 0 : h[0]) == null ? void 0 : o.data) == null ? void 0 : a["page-info"], _ = (u = (c = h == null ? void 0 : h[0]) == null ? void 0 : c.data) == null ? void 0 : u.aggregate, g = Vt(h), y = this.ensureAttrs(), w = te(
          y,
          g,
          r,
          this.config.useDateObjects
        );
        this.querySubs.updateInPlace((S) => {
          if (!S[p]) {
            this._log.info("Missing value in querySubs", { hash: p, q: d });
            return;
          }
          S[p].result = {
            store: w,
            attrsStore: y,
            pageInfo: b,
            aggregate: _,
            processedTxId: t["processed-tx-id"]
          };
        }), this._cleanupPendingMutationsQueries(), this.notifyOne(p), this.notifyOneQueryOnce(p), this._cleanupPendingMutationsTimeout();
        break;
      }
      case "start-sync-ok": {
        this._syncTable.onStartSyncOk(t);
        break;
      }
      case "sync-load-batch": {
        this._syncTable.onSyncLoadBatch(t);
        break;
      }
      case "sync-init-finish": {
        this._syncTable.onSyncInitFinish(t);
        break;
      }
      case "sync-update-triples": {
        this._syncTable.onSyncUpdateTriples(t);
        break;
      }
      case "refresh-ok": {
        const { computations: d, attrs: h } = t, p = t["processed-tx-id"];
        h && this._setAttrs(h), this._cleanupPendingMutationsTimeout();
        const b = this._rewriteMutations(
          this.ensureAttrs(),
          this._pendingMutations(),
          p
        );
        b !== this._pendingMutations() && this.kv.updateInPlace((y) => {
          y.pendingMutations = b;
        });
        const _ = Xt(b.entries()), g = d.map((y) => {
          var wt, Tt, mt, St;
          const w = y["instaql-query"], S = y["instaql-result"], m = M(w), v = Vt(S), O = this.ensureAttrs(), L = te(
            O,
            v,
            r,
            this.config.useDateObjects
          ), { store: Re, attrsStore: Qn } = this._applyOptimisticUpdates(
            L,
            O,
            _,
            p
          ), Wn = (Tt = (wt = S == null ? void 0 : S[0]) == null ? void 0 : wt.data) == null ? void 0 : Tt["page-info"], Gn = (St = (mt = S == null ? void 0 : S[0]) == null ? void 0 : mt.data) == null ? void 0 : St.aggregate;
          return {
            q: w,
            hash: m,
            store: Re,
            attrsStore: Qn,
            pageInfo: Wn,
            aggregate: Gn
          };
        });
        g.forEach(
          ({ hash: y, q: w, store: S, attrsStore: m, pageInfo: v, aggregate: O }) => {
            this.querySubs.updateInPlace((L) => {
              if (!L[y]) {
                this._log.error("Missing value in querySubs", { hash: y, q: w });
                return;
              }
              L[y].result = {
                store: S,
                attrsStore: m,
                pageInfo: v,
                aggregate: O,
                processedTxId: p
              };
            });
          }
        ), this._cleanupPendingMutationsQueries(), g.forEach(({ hash: y }) => {
          this.notifyOne(y);
        });
        break;
      }
      case "transact-ok": {
        const { "client-event-id": d, "tx-id": h } = t;
        this._inFlightMutationEventIds.delete(d);
        const b = this._rewriteMutations(
          this.ensureAttrs(),
          this._pendingMutations()
        ).get(d);
        if (!b)
          break;
        this._updatePendingMutations((g) => {
          g.set(d, {
            ...g.get(d),
            "tx-id": h,
            confirmed: Date.now()
          });
        });
        const _ = [];
        for (const g of b["tx-steps"])
          if (g[0] === "add-attr") {
            const y = g[1];
            _.push(y);
          }
        if (_.length) {
          const g = Object.values(this.ensureAttrs().attrs);
          this._setAttrs([...g, ..._]);
        }
        this._finishTransaction("synced", d), this._cleanupPendingMutationsTimeout();
        break;
      }
      case "patch-presence": {
        const d = t["room-id"];
        this._trySetRoomConnected(d, !0), this._patchPresencePeers(d, t.edits), this._notifyPresenceSubs(d);
        break;
      }
      case "refresh-presence": {
        const d = t["room-id"];
        this._trySetRoomConnected(d, !0), this._setPresencePeers(d, t.data), this._notifyPresenceSubs(d);
        break;
      }
      case "server-broadcast": {
        const d = t["room-id"], h = t.topic;
        this._trySetRoomConnected(d, !0), this._notifyBroadcastSubs(d, h, t);
        break;
      }
      case "join-room-ok": {
        const d = t["room-id"];
        if (!this._rooms[d]) {
          this._roomsPendingLeave[d] && (this._tryLeaveRoom(d), delete this._roomsPendingLeave[d]);
          break;
        }
        this._trySetRoomConnected(d, !0), this._flushEnqueuedRoomData(d);
        break;
      }
      case "leave-room-ok": {
        const d = t["room-id"];
        this._trySetRoomConnected(d, !1);
        break;
      }
      case "join-room-error":
        const l = t["room-id"], f = this._rooms[l];
        f && (f.error = t.error), this._notifyPresenceSubs(l);
        break;
      case "error":
        this._handleReceiveError(t);
        break;
      default:
        this._log.info("Uknown op", t.op, t);
        break;
    }
  }
  _pendingMutations() {
    return this.kv.currentValue.pendingMutations ?? /* @__PURE__ */ new Map();
  }
  _updatePendingMutations(e) {
    this.kv.updateInPlace((t) => {
      const r = t.pendingMutations ?? /* @__PURE__ */ new Map();
      t.pendingMutations = r, e(r);
    });
  }
  /**
   * @param {'timeout' | 'error'} status
   * @param {string} eventId
   * @param {{message?: string, type?: string, status?: number, hint?: unknown}} errorMsg
   */
  _handleMutationError(e, t, r) {
    const s = this._pendingMutations().get(t);
    if (s && (e !== "timeout" || !s["tx-id"])) {
      this._updatePendingMutations((o) => (o.delete(t), o)), this._inFlightMutationEventIds.delete(t);
      const i = {
        message: r.message,
        hint: r.hint
      };
      this.notifyAll(), this.notifyAttrsSubs(), this.notifyMutationErrorSubs(i), this._finishTransaction(e, t, r);
    }
  }
  _handleReceiveError(e) {
    var a, c, u, l, f, d, h;
    console.log("error", e);
    const t = e["client-event-id"];
    this._inFlightMutationEventIds.delete(t);
    const r = this._pendingMutations().get(t), s = {
      message: e.message || "Uh-oh, something went wrong. Ping Joe & Stopa."
    };
    if (e.hint && (s.hint = e.hint), r) {
      this._handleMutationError("error", t, e);
      return;
    }
    if ((a = e["original-event"]) != null && a.hasOwnProperty("q") && ((c = e["original-event"]) == null ? void 0 : c.op) === "add-query") {
      const p = (u = e["original-event"]) == null ? void 0 : u.q, b = M(p);
      this.notifyQueryError(M(p), s), this.notifyQueryOnceError(p, b, t, s);
      return;
    }
    if (((l = e["original-event"]) == null ? void 0 : l.op) === "init") {
      if (e.type === "record-not-found" && ((f = e.hint) == null ? void 0 : f["record-type"]) === "app-user") {
        this.changeCurrentUser(null);
        return;
      }
      this._setStatus(W.ERRORED, s), this.notifyAll();
      return;
    }
    if (((d = e["original-event"]) == null ? void 0 : d.op) === "resync-table") {
      this._syncTable.onResyncError(e);
      return;
    }
    if (((h = e["original-event"]) == null ? void 0 : h.op) === "start-sync") {
      this._syncTable.onStartSyncError(e);
      return;
    }
    const o = { ...e };
    delete o.message, delete o.hint, console.error(e.message, o), e.hint && console.error(
      `This error comes with some debugging information. Here it is: 
`,
      e.hint
    );
  }
  notifyQueryOnceError(e, t, r, s) {
    var o;
    const i = (o = this.queryOnceDfds[t]) == null ? void 0 : o.find((a) => a.eventId === r);
    i && (i.dfd.reject(s), this._completeQueryOnce(e, t, i.dfd));
  }
  _setAttrs(e) {
    this.attrs = new H(
      e.reduce((t, r) => (t[r.id] = r, t), {}),
      this._linkIndex
    ), this.notifyAttrsSubs();
  }
  _startQuerySub(e, t) {
    const r = P();
    return this.querySubs.updateInPlace((s) => {
      s[t] = s[t] || { q: e, result: null, eventId: r }, s[t].lastAccessed = Date.now();
    }), this._trySendAuthed(r, { op: "add-query", q: e }), r;
  }
  subscribeTable(e, t) {
    return this._syncTable.subscribe(e, t);
  }
  /**
   *  When a user subscribes to a query the following side effects occur:
   *
   *  - We update querySubs to include the new query
   *  - We update queryCbs to include the new cb
   *  - If we already have a result for the query we call cb immediately
   *  - We send the server an `add-query` message
   *
   *  Returns an unsubscribe function
   */
  subscribeQuery(e, t, r) {
    this.config.disableValidation || Wt(e, this.config.schema), r && "ruleParams" in r && (e = { $$ruleParams: r.ruleParams, ...e });
    const s = M(e), i = this.getPreviousResult(e);
    return i && t(i), this.queryCbs[s] = this.queryCbs[s] ?? [], this.queryCbs[s].push({ q: e, cb: t }), this._startQuerySub(e, s), () => {
      this._unsubQuery(e, s, t);
    };
  }
  queryOnce(e, t) {
    this.config.disableValidation || Wt(e, this.config.schema), t && "ruleParams" in t && (e = { $$ruleParams: t.ruleParams, ...e });
    const r = new zt();
    if (!this._isOnline)
      return r.reject(
        new Error("We can't run `queryOnce`, because the device is offline.")
      ), r.promise;
    if (!this.querySubs)
      return r.reject(
        new Error(
          "We can't run `queryOnce` on the backend. Use adminAPI.query instead: https://www.instantdb.com/docs/backend#query"
        )
      ), r.promise;
    const s = M(e), i = this._startQuerySub(e, s);
    return this.queryOnceDfds[s] = this.queryOnceDfds[s] ?? [], this.queryOnceDfds[s].push({ q: e, dfd: r, eventId: i }), setTimeout(
      () => r.reject(new Error("Query timed out")),
      Yi
    ), r.promise;
  }
  _completeQueryOnce(e, t, r) {
    this.queryOnceDfds[t] && (this.queryOnceDfds[t] = this.queryOnceDfds[t].filter(
      (s) => s.dfd !== r
    ), this._cleanupQuery(e, t));
  }
  _unsubQuery(e, t, r) {
    this.queryCbs[t] && (this.queryCbs[t] = this.queryCbs[t].filter((s) => s.cb !== r), this._cleanupQuery(e, t));
  }
  _hasQueryListeners(e) {
    var t, r;
    return !!((t = this.queryCbs[e]) != null && t.length || (r = this.queryOnceDfds[e]) != null && r.length);
  }
  _cleanupQuery(e, t) {
    this._hasQueryListeners(t) || (delete this.queryCbs[t], delete this.queryOnceDfds[t], delete this._dataForQueryCache[t], this.querySubs.unloadKey(t), this._trySendAuthed(P(), { op: "remove-query", q: e }));
  }
  // When we `pushTx`, it's possible that we don't yet have `this.attrs`
  // This means that `tx-steps` in `pendingMutations` will include `add-attr`
  // commands for attrs that already exist.
  //
  // This will also affect `add-triple` and `retract-triple` which
  // reference attr-ids that do not match the server.
  //
  // We fix this by rewriting `tx-steps` in each `pendingMutation`.
  // We remove `add-attr` commands for attrs that already exist.
  // We update `add-triple` and `retract-triple` commands to use the
  // server attr-ids.
  /**
   *
   * @param {s.AttrsStore} attrs
   * @param {any} muts
   * @param {number} [processedTxId]
   */
  _rewriteMutations(e, t, r) {
    if (!e) return t;
    if (!t) return /* @__PURE__ */ new Map();
    const s = (l) => {
      const [f, d, h] = l["forward-identity"];
      return C(e, d, h);
    }, i = (l) => {
      const [f, d, h] = l["forward-identity"];
      return X(e, d, h);
    }, o = { attrIdMap: {}, refSwapAttrIds: /* @__PURE__ */ new Set() };
    let a = !1;
    const c = (l, f) => {
      const d = [];
      for (const h of l) {
        const [p] = h;
        if (p === "add-attr") {
          const [_, g] = h, y = s(g);
          if (y && g.id !== y.id) {
            o.attrIdMap[g.id] = y.id, a = !0;
            continue;
          }
          if (g["value-type"] === "ref") {
            const w = i(g);
            if (w) {
              o.attrIdMap[g.id] = w.id, o.refSwapAttrIds.add(g.id), a = !0;
              continue;
            }
          }
        }
        if (r && f && r >= f && p === "add-attr" || p === "update-attr" || p === "delete-attr") {
          a = !0;
          continue;
        }
        const b = a ? Fs(o, h) : h;
        d.push(b);
      }
      return a ? d : l;
    }, u = /* @__PURE__ */ new Map();
    for (const [l, f] of t.entries())
      u.set(l, {
        ...f,
        "tx-steps": c(f["tx-steps"], f["tx-id"])
      });
    return a ? u : t;
  }
  _rewriteMutationsSorted(e, t) {
    return Xt(this._rewriteMutations(e, t).entries());
  }
  // ---------------------------
  // Transact
  /**
   * @returns {s.AttrsStore}
   */
  optimisticAttrs() {
    var i, o;
    const e = [...this._pendingMutations().values()].flatMap((a) => a["tx-steps"]), t = new Set(
      e.filter(([a, c]) => a === "delete-attr").map(([a, c]) => c)
    ), r = [];
    for (const [a, c] of e)
      if (a === "add-attr")
        r.push(c);
      else if (a === "update-attr" && c.id && ((i = this.attrs) != null && i.getAttr(c.id))) {
        const u = { ...this.attrs.getAttr(c.id), ...c };
        r.push(u);
      }
    if (!t.size && !r.length)
      return this.attrs || new H({}, this._linkIndex);
    const s = { ...((o = this.attrs) == null ? void 0 : o.attrs) || {} };
    for (const a of r)
      s[a.id] = a;
    for (const a of t)
      delete s[a];
    return new H(s, this._linkIndex);
  }
  /** Runs instaql on a query and a store */
  dataForQuery(e, t = !0) {
    const r = this._errorMessage;
    if (r)
      return { error: r };
    if (!this.querySubs || !this.kv.currentValue.pendingMutations) return;
    const s = this.querySubs.version(), i = this.querySubs.currentValue, o = this.kv.version(), a = this._pendingMutations(), { q: c, result: u } = i[e] || {};
    if (!u) return;
    const l = this._dataForQueryCache[e];
    if (l && s === l.querySubVersion && o === l.pendingMutationsVersion)
      return l;
    let f = u.store, d = u.attrsStore;
    const { pageInfo: h, aggregate: p, processedTxId: b } = u, _ = this._rewriteMutationsSorted(
      d,
      a
    );
    if (t) {
      const y = this._applyOptimisticUpdates(
        f,
        d,
        _,
        b
      );
      f = y.store, d = y.attrsStore;
    }
    return { data: gt(
      { store: f, attrsStore: d, pageInfo: h, aggregate: p },
      c
    ), querySubVersion: s, pendingMutationsVersion: o };
  }
  _applyOptimisticUpdates(e, t, r, s) {
    for (const [i, o] of r)
      if (!o["tx-id"] || s && o["tx-id"] > s) {
        const a = qr(e, t, o["tx-steps"]);
        e = a.store, t = a.attrsStore;
      }
    return { store: e, attrsStore: t };
  }
  /** Re-compute all subscriptions */
  notifyAll() {
    Object.keys(this.queryCbs).forEach((e) => {
      this.querySubs.waitForKeyToLoad(e).then(() => this.notifyOne(e)).catch(() => this.notifyOne(e));
    });
  }
  loadedNotifyAll() {
    this.kv.waitForKeyToLoad("pendingMutations").then(() => this.notifyAll()).catch(() => this.notifyAll());
  }
  shutdown() {
    var e;
    this._log.info("[shutdown]", this.config.appId), this._isShutdown = !0, (e = this._transport) == null || e.close();
  }
  /**
   * Sends mutation to server and schedules a timeout to cancel it if
   * we don't hear back in time.
   * Note: If we're offline we don't schedule a timeout, we'll schedule it
   * later once we're back online and send the mutation again
   *
   */
  _sendMutation(e, t) {
    if (t.error) {
      this._handleMutationError("error", e, {
        message: t.error.message
      });
      return;
    }
    if (this.status !== W.AUTHENTICATED) {
      this._finishTransaction("enqueued", e);
      return;
    }
    const r = Math.max(
      6e3,
      Math.min(
        this._inFlightMutationEventIds.size + 1,
        // Defensive code in case we don't clean up in flight mutation event ids
        this._pendingMutations().size + 1
      ) * 6e3
    );
    this._isOnline ? (this._trySend(e, t), setTimeout(() => {
      this._isOnline && this._handleMutationError("timeout", e, {
        message: "transaction timed out"
      });
    }, r)) : this._finishTransaction("enqueued", e);
  }
  // ---------------------------
  // Websocket
  /** Send messages we accumulated while we were connecting */
  _flushPendingMessages() {
    Object.keys(this.queryCbs).map((s) => this.querySubs.currentValue[s]).filter((s) => s).forEach(({ eventId: s, q: i }) => {
      this._trySendAuthed(s, { op: "add-query", q: i });
    }), Object.values(this.queryOnceDfds).flat().forEach(({ eventId: s, q: i }) => {
      this._trySendAuthed(s, { op: "add-query", q: i });
    }), this._rewriteMutationsSorted(
      this.ensureAttrs(),
      this._pendingMutations()
    ).forEach(([s, i]) => {
      i["tx-id"] || this._sendMutation(s, i);
    }), this._syncTable.flushPending();
  }
  /**
   * Clean up pendingMutations that all queries have seen
   */
  _cleanupPendingMutationsQueries() {
    let e = Number.MAX_SAFE_INTEGER;
    for (const { result: t } of Object.values(this.querySubs.currentValue))
      t != null && t.processedTxId && (e = Math.min(e, t == null ? void 0 : t.processedTxId));
    this._updatePendingMutations((t) => {
      for (const [r, s] of Array.from(t.entries()))
        s["tx-id"] && s["tx-id"] <= e && t.delete(r);
    });
  }
  /**
   * After mutations is confirmed by server, we give each query 30 sec
   * to update its results. If that doesn't happen, we assume query is
   * unaffected by this mutation and its safe to delete it from local queue
   */
  _cleanupPendingMutationsTimeout() {
    if (this._pendingMutations().size < this._pendingMutationCleanupThreshold)
      return;
    const e = Date.now();
    this._updatePendingMutations((t) => {
      for (const [r, s] of Array.from(t.entries()))
        s.confirmed && s.confirmed + this._pendingTxCleanupTimeout < e && t.delete(r);
    });
  }
  _trySendAuthed(...e) {
    this.status === W.AUTHENTICATED && this._trySend(...e);
  }
  _trySend(e, t, r) {
    if (this._transport.isOpen()) {
      switch (Zt[t.op] || this._log.info("[send]", this._transport.id, t.op, t), t.op) {
        case "transact": {
          this._inFlightMutationEventIds.add(e);
          break;
        }
        case "init":
          this._inFlightMutationEventIds.clear();
      }
      this._transport.send({ "client-event-id": e, ...t });
    }
  }
  _startSocket() {
    if (this._wsOk = null, this._isShutdown) {
      this._log.info(
        "[socket][start]",
        this.config.appId,
        "Reactor has been shut down and will not start a new socket"
      );
      return;
    }
    if (this._transport && this._transport.isConnecting()) {
      this._log.info(
        "[socket][start]",
        this._transport.id,
        "maintained as current transport, we were still in a connecting state"
      );
      return;
    }
    const e = this._transport;
    this._transport = no({
      transportType: this._transportType,
      appId: this.config.appId,
      apiURI: this.config.apiURI,
      wsURI: this.config.websocketURI,
      EventSourceImpl: this._EventSource
    }), this._transport.onopen = this._transportOnOpen, this._transport.onmessage = this._transportOnMessage, this._transport.onclose = this._transportOnClose, this._transport.onerror = this._transportOnError, this._log.info("[socket][start]", this._transport.id), e != null && e.isOpen() && (this._log.info(
      "[socket][start]",
      this._transport.id,
      "close previous transport id = ",
      e.id
    ), e.close());
  }
  /**
   * Given a key, returns a stable local id, unique to this device and app.
   *
   * This can be useful if you want to create guest ids for example.
   *
   * Note: If the user deletes their local storage, this id will change.
   *
   */
  async getLocalId(e) {
    const t = `localToken_${e}`;
    if (this.kv.currentValue[t])
      return this.kv.currentValue[t];
    const r = await this.kv.waitForKeyToLoad(t);
    if (r)
      return r;
    const s = P();
    return this.kv.updateInPlace((i) => {
      i[t] || (i[t] = s);
    }), await this.kv.waitForKeyToLoad(t);
  }
  // ----
  // Auth
  _replaceUrlAfterOAuth() {
    if (typeof URL > "u")
      return;
    const e = new URL(window.location.href);
    if (e.searchParams.get(qe)) {
      const t = e.toString();
      e.searchParams.delete(qe), e.searchParams.delete("code"), e.searchParams.delete("error");
      const r = e.pathname + (e.searchParams.size ? "?" + e.searchParams : "") + e.hash;
      if (history.replaceState(history.state, "", r), // @ts-ignore (waiting for ts support)
      typeof navigation == "object" && // @ts-ignore (waiting for ts support)
      typeof navigation.addEventListener == "function" && // @ts-ignore (waiting for ts support)
      typeof navigation.removeEventListener == "function") {
        let s = !1;
        const i = (o) => {
          var a;
          s || (s = !0, navigation.removeEventListener("navigate", i), !o.userInitiated && o.navigationType === "replace" && ((a = o.destination) == null ? void 0 : a.url) === t && history.replaceState(history.state, "", r));
        };
        navigation.addEventListener("navigate", i);
      }
    }
  }
  /**
   *
   * @returns Promise<null | {error: {message: string}}>
   */
  async _oauthLoginInit() {
    var s, i, o, a;
    if (typeof window > "u" || typeof window.location > "u" || typeof URLSearchParams > "u")
      return null;
    const e = new URLSearchParams(window.location.search);
    if (!e.get(qe))
      return null;
    const t = e.get("error");
    if (t)
      return this._replaceUrlAfterOAuth(), { error: { message: t } };
    const r = e.get("code");
    if (!r)
      return null;
    this._replaceUrlAfterOAuth();
    try {
      const c = await this._getCurrentUser(), u = (c == null ? void 0 : c.type) === "guest", { user: l } = await qt({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        code: r,
        refreshToken: u ? c.refresh_token : void 0
      });
      return this.setCurrentUser(l), null;
    } catch (c) {
      return ((s = c == null ? void 0 : c.body) == null ? void 0 : s.type) === "record-not-found" && ((o = (i = c == null ? void 0 : c.body) == null ? void 0 : i.hint) == null ? void 0 : o["record-type"]) === "app-oauth-code" && await this._hasCurrentUser() ? null : { error: { message: ((a = c == null ? void 0 : c.body) == null ? void 0 : a.message) || "Error logging in." } };
    }
  }
  async _waitForOAuthCallbackResponse() {
    return await this._oauthCallbackResponse;
  }
  __subscribeMutationErrors(e) {
    return this.mutationErrorCbs.push(e), () => {
      this.mutationErrorCbs = this.mutationErrorCbs.filter((t) => t !== e);
    };
  }
  subscribeAuth(e) {
    this.authCbs.push(e);
    const t = this._currentUserCached;
    t.isLoading || e(this._currentUserCached);
    let r = !1;
    return this.getCurrentUser().then((s) => {
      r || Oe(s, t) || e(s);
    }), () => {
      r = !0, this.authCbs = this.authCbs.filter((s) => s !== e);
    };
  }
  async getAuth() {
    const { user: e, error: t } = await this.getCurrentUser();
    if (t)
      throw new pe("Could not get current user: " + t.message);
    return e;
  }
  subscribeConnectionStatus(e) {
    return this.connectionStatusCbs.push(e), () => {
      this.connectionStatusCbs = this.connectionStatusCbs.filter(
        (t) => t !== e
      );
    };
  }
  subscribeAttrs(e) {
    return this.attrsCbs.push(e), this.attrs && e(this.attrs.attrs), () => {
      this.attrsCbs = this.attrsCbs.filter((t) => t !== e);
    };
  }
  notifyAuthSubs(e) {
    this.authCbs.forEach((t) => t(e));
  }
  notifyMutationErrorSubs(e) {
    this.mutationErrorCbs.forEach((t) => t(e));
  }
  notifyAttrsSubs() {
    if (!this.attrs) return;
    const e = this.optimisticAttrs();
    this.attrsCbs.forEach((t) => t(e.attrs));
  }
  notifyConnectionStatusSubs(e) {
    this.connectionStatusCbs.forEach((t) => t(e));
  }
  async setCurrentUser(e) {
    this.kv.updateInPlace((t) => {
      t[oe] = e;
    }), await this.kv.waitForKeyToLoad(oe);
  }
  getCurrentUserCached() {
    return this._currentUserCached;
  }
  async _getCurrentUser() {
    const e = await this.kv.waitForKeyToLoad(oe);
    return typeof e == "string" ? JSON.parse(e) : e;
  }
  async getCurrentUser() {
    const e = await this._waitForOAuthCallbackResponse();
    if (e != null && e.error) {
      const t = { error: e.error, user: void 0 };
      return this._currentUserCached = { isLoading: !1, ...t }, t;
    }
    try {
      const r = { user: await this._getCurrentUser(), error: void 0 };
      return this._currentUserCached = {
        isLoading: !1,
        ...r
      }, r;
    } catch (t) {
      return {
        user: void 0,
        isLoading: !1,
        error: { message: (t == null ? void 0 : t.message) || "Error loading user" }
      };
    }
  }
  async _hasCurrentUser() {
    const e = await this.kv.waitForKeyToLoad(oe);
    return typeof e == "string" ? JSON.parse(e) != null : e != null;
  }
  async changeCurrentUser(e) {
    var r;
    const { user: t } = await this.getCurrentUser();
    if (!Oe(t, e)) {
      await this.setCurrentUser(e), this.updateUser(e);
      try {
        (r = this._broadcastChannel) == null || r.postMessage({ type: "auth" });
      } catch (s) {
        console.error("Error posting message to broadcast channel", s);
      }
    }
  }
  async syncUserToEndpoint(e) {
    if (this.config.firstPartyPath)
      try {
        fetch(this.config.firstPartyPath + "/", {
          method: "POST",
          body: JSON.stringify({
            type: "sync-user",
            appId: this.config.appId,
            user: e
          }),
          headers: {
            "Content-Type": "application/json"
          }
        });
      } catch (t) {
        this._log.error("Error syncing user with external endpoint", t);
      }
  }
  updateUser(e) {
    this.syncUserToEndpoint(e);
    const t = { error: void 0, user: e };
    this._currentUserCached = { isLoading: !1, ...t }, this._dataForQueryCache = {}, this.querySubs.updateInPlace((r) => {
      Object.keys(r).forEach((s) => {
        delete r[s].result;
      });
    }), this._reconnectTimeoutMs = 0, this._transport.close(), this._oauthCallbackResponse = null, this.notifyAuthSubs(t);
  }
  sendMagicCode({ email: e }) {
    return wi({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      email: e
    });
  }
  async signInWithMagicCode({ email: e, code: t }) {
    var o;
    const r = await this.getCurrentUser(), s = ((o = r == null ? void 0 : r.user) == null ? void 0 : o.type) === "guest", i = await Ti({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      email: e,
      code: t,
      refreshToken: s ? r.user.refresh_token : void 0
    });
    return await this.changeCurrentUser(i.user), i;
  }
  async signInWithCustomToken(e) {
    const t = await mi({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      refreshToken: e
    });
    return await this.changeCurrentUser(t.user), t;
  }
  async signInAsGuest() {
    const e = await Si({
      apiURI: this.config.apiURI,
      appId: this.config.appId
    });
    return await this.changeCurrentUser(e.user), e;
  }
  potentiallyInvalidateToken(e, t) {
    var i;
    const r = (i = e == null ? void 0 : e.user) == null ? void 0 : i.refresh_token;
    if (!r)
      return;
    if (t.invalidateToken === !1) {
      this._log.info("[auth-invalidate] skipped invalidateToken");
      return;
    }
    Oi({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      refreshToken: r
    }).then(() => {
      this._log.info("[auth-invalidate] completed invalidateToken");
    }).catch((o) => {
    });
  }
  async signOut(e) {
    const t = await this.getCurrentUser();
    this.potentiallyInvalidateToken(t, e), await this.changeCurrentUser(null);
  }
  /**
   * Creates an OAuth authorization URL.
   *
   * @param {Object} params - The parameters to create the authorization URL.
   * @param {string} params.clientName - The name of the client requesting authorization.
   * @param {string} params.redirectURL - The URL to redirect users to after authorization.
   * @returns {string} The created authorization URL.
   */
  createAuthorizationURL({ clientName: e, redirectURL: t }) {
    const { apiURI: r, appId: s } = this.config;
    return `${r}/runtime/oauth/start?app_id=${s}&client_name=${e}&redirect_uri=${t}`;
  }
  /**
   * @param {Object} params
   * @param {string} params.code - The code received from the OAuth service.
   * @param {string} [params.codeVerifier] - The code verifier used to generate the code challenge.
   */
  async exchangeCodeForToken({ code: e, codeVerifier: t }) {
    var o;
    const r = await this.getCurrentUser(), s = ((o = r == null ? void 0 : r.user) == null ? void 0 : o.type) === "guest", i = await qt({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      code: e,
      codeVerifier: t,
      refreshToken: s ? r.user.refresh_token : void 0
    });
    return await this.changeCurrentUser(i.user), i;
  }
  issuerURI() {
    const { apiURI: e, appId: t } = this.config;
    return `${e}/runtime/${t}`;
  }
  /**
   * @param {Object} params
   * @param {string} params.clientName - The name of the client requesting authorization.
   * @param {string} params.idToken - The id_token from the external service
   * @param {string | null | undefined} [params.nonce] - The nonce used when requesting the id_token from the external service
   */
  async signInWithIdToken({ idToken: e, clientName: t, nonce: r }) {
    var a;
    const s = await this.getCurrentUser(), i = (a = s == null ? void 0 : s.user) == null ? void 0 : a.refresh_token, o = await Ai({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      idToken: e,
      clientName: t,
      nonce: r,
      refreshToken: i
    });
    return await this.changeCurrentUser(o.user), o;
  }
  // --------
  // Rooms
  /**
   * @param {string} roomId
   * @param {any | null | undefined} [initialPresence] -- initial presence data to send when joining the room
   * @returns () => void
   */
  joinRoom(e, t) {
    let r = !1;
    this._rooms[e] || (r = !0, this._rooms[e] = {
      isConnected: !1,
      error: void 0
    }), this._presence[e] = this._presence[e] || {};
    const s = this._presence[e].result;
    return t && !s && (this._presence[e].result = this._presence[e].result || {}, this._presence[e].result.user = t, this._notifyPresenceSubs(e)), r && this._tryJoinRoom(e, t), () => {
      this._cleanupRoom(e);
    };
  }
  _cleanupRoom(e) {
    var t, r, s;
    if (!((r = (t = this._presence[e]) == null ? void 0 : t.handlers) != null && r.length) && !Object.keys(this._broadcastSubs[e] ?? {}).length) {
      const i = (s = this._rooms[e]) == null ? void 0 : s.isConnected;
      delete this._rooms[e], delete this._presence[e], delete this._broadcastSubs[e], i ? this._tryLeaveRoom(e) : this._roomsPendingLeave[e] = !0;
    }
  }
  // --------
  // Presence
  // TODO: look into typing again
  getPresence(e, t, r = {}) {
    const s = this._rooms[t], i = this._presence[t];
    return !s || !i || !i.result ? null : {
      ...Mi(i.result, r, this._sessionId),
      isLoading: !s.isConnected,
      error: s.error
    };
  }
  // TODO: look into typing again
  publishPresence(e, t, r) {
    const s = this._rooms[t], i = this._presence[t];
    if (!s || !i)
      return;
    i.result = i.result || {};
    const o = {
      ...i.result.user,
      ...r
    };
    i.result.user = o, s.isConnected && (this._trySetPresence(t, o), this._notifyPresenceSubs(t));
  }
  _trySetPresence(e, t) {
    this._trySendAuthed(P(), {
      op: "set-presence",
      "room-id": e,
      data: t
    });
  }
  _tryJoinRoom(e, t) {
    this._trySendAuthed(P(), { op: "join-room", "room-id": e, data: t }), delete this._roomsPendingLeave[e];
  }
  _tryLeaveRoom(e) {
    this._trySendAuthed(P(), { op: "leave-room", "room-id": e });
  }
  _trySetRoomConnected(e, t) {
    const r = this._rooms[e];
    r && (r.isConnected = t);
  }
  // TODO: look into typing again
  subscribePresence(e, t, r, s) {
    const i = this.joinRoom(
      t,
      // Oct 28, 2025
      // Note: initialData is deprecated.
      // Keeping here for backwards compatibility
      r.initialPresence || r.initialData
    ), o = { ...r, roomId: t, cb: s, prev: null };
    return this._presence[t] = this._presence[t] || {}, this._presence[t].handlers = this._presence[t].handlers || [], this._presence[t].handlers.push(o), this._notifyPresenceSub(t, o), () => {
      var a, c;
      this._presence[t].handlers = ((c = (a = this._presence[t]) == null ? void 0 : a.handlers) == null ? void 0 : c.filter((u) => u !== o)) ?? [], i();
    };
  }
  _notifyPresenceSubs(e) {
    var t, r;
    (r = (t = this._presence[e]) == null ? void 0 : t.handlers) == null || r.forEach((s) => {
      this._notifyPresenceSub(e, s);
    });
  }
  _notifyPresenceSub(e, t) {
    const r = this.getPresence("", e, t);
    r && (t.prev && !Pi(r, t.prev) || (t.prev = r, t.cb(r)));
  }
  _patchPresencePeers(e, t) {
    var o, a, c;
    const r = ((a = (o = this._presence[e]) == null ? void 0 : o.result) == null ? void 0 : a.peers) || {};
    let s = Object.fromEntries(
      Object.entries(r).map(([u, l]) => [u, { data: l }])
    );
    (c = this._presence[e]) == null || c.result;
    const i = Ee(s, (u) => {
      for (let [l, f, d] of t)
        switch (f) {
          case "+":
            ur(u, l, d);
            break;
          case "r":
            It(u, l, d);
            break;
          case "-":
            dn(u, l);
            break;
        }
      delete u[this._sessionId];
    });
    this._setPresencePeers(e, i);
  }
  _setPresencePeers(e, t) {
    const r = { ...t };
    delete r[this._sessionId];
    const s = Object.fromEntries(
      Object.entries(r).map(([i, o]) => [i, o.data])
    );
    this._presence = Ee(this._presence, (i) => {
      It(i, [e, "result", "peers"], s);
    });
  }
  // --------
  // Broadcast
  publishTopic({ roomType: e, roomId: t, topic: r, data: s }) {
    const i = this._rooms[t];
    if (i) {
      if (!i.isConnected) {
        this._broadcastQueue[t] = this._broadcastQueue[t] ?? [], this._broadcastQueue[t].push({ topic: r, roomType: e, data: s });
        return;
      }
      this._tryBroadcast(t, e, r, s);
    }
  }
  _tryBroadcast(e, t, r, s) {
    this._trySendAuthed(P(), {
      op: "client-broadcast",
      "room-id": e,
      roomType: t,
      topic: r,
      data: s
    });
  }
  subscribeTopic(e, t, r) {
    const s = this.joinRoom(e);
    return this._broadcastSubs[e] = this._broadcastSubs[e] || {}, this._broadcastSubs[e][t] = this._broadcastSubs[e][t] || [], this._broadcastSubs[e][t].push(r), this._presence[e] = this._presence[e] || {}, () => {
      this._broadcastSubs[e][t] = this._broadcastSubs[e][t].filter((i) => i !== r), this._broadcastSubs[e][t].length || delete this._broadcastSubs[e][t], s();
    };
  }
  _notifyBroadcastSubs(e, t, r) {
    var s, i, o;
    (o = (i = (s = this._broadcastSubs) == null ? void 0 : s[e]) == null ? void 0 : i[t]) == null || o.forEach((a) => {
      var l, f, d, h, p, b;
      const c = (l = r.data) == null ? void 0 : l.data, u = r.data["peer-id"] === this._sessionId ? (d = (f = this._presence[e]) == null ? void 0 : f.result) == null ? void 0 : d.user : (b = (p = (h = this._presence[e]) == null ? void 0 : h.result) == null ? void 0 : p.peers) == null ? void 0 : b[r.data["peer-id"]];
      return a(c, u);
    });
  }
  // --------
  // Storage
  async uploadFile(e, t, r) {
    var o;
    const s = await this.getCurrentUser(), i = (o = s == null ? void 0 : s.user) == null ? void 0 : o.refresh_token;
    return vi({
      ...r,
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      path: e,
      file: t,
      refreshToken: i
    });
  }
  async deleteFile(e) {
    var i;
    const t = await this.getCurrentUser(), r = (i = t == null ? void 0 : t.user) == null ? void 0 : i.refresh_token;
    return await ki({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      path: e,
      refreshToken: r
    });
  }
  // Deprecated Storage API (Jan 2025)
  // ---------------------------------
  async upload(e, t) {
    var c;
    const r = await this.getCurrentUser(), s = (c = r == null ? void 0 : r.user) == null ? void 0 : c.refresh_token, i = e || t.name, o = await Ei({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      fileName: i,
      refreshToken: s
    });
    return await Ii(o, t);
  }
  async getDownloadUrl(e) {
    var i;
    const t = await this.getCurrentUser(), r = (i = t == null ? void 0 : t.user) == null ? void 0 : i.refresh_token;
    return await Ci({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      path: e,
      refreshToken: r
    });
  }
}
function lo(n, e) {
  return new De(
    Vn(n, e),
    // (XXX): LinksDef<any> stems from TypeScripts inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    e,
    void 0
  );
}
function fo(n) {
  return new $e(n, {});
}
function ho() {
  return new D("string", !0, !1);
}
function po() {
  return new D("number", !0, !1);
}
function yo() {
  return new D("boolean", !0, !1);
}
function bo() {
  return new D("date", !0, !1);
}
function go() {
  return new D("json", !0, !1);
}
function _o() {
  return new D("json", !0, !1);
}
function Vn(n, e) {
  var s, i, o, a;
  const t = { fwd: {}, rev: {} };
  for (const c of Object.values(e))
    (s = t.fwd)[i = c.forward.on] || (s[i] = {}), (o = t.rev)[a = c.reverse.on] || (o[a] = {}), t.fwd[c.forward.on][c.forward.label] = {
      entityName: c.reverse.on,
      cardinality: c.forward.has
    }, t.rev[c.reverse.on][c.reverse.label] = {
      entityName: c.forward.on,
      cardinality: c.reverse.has
    };
  return Object.fromEntries(
    Object.entries(n).map(([c, u]) => [
      c,
      new $e(u.attrs, {
        ...t.fwd[c],
        ...t.rev[c]
      })
    ])
  );
}
function wo({
  entities: n,
  links: e,
  rooms: t
}) {
  const r = e ?? {}, s = t ?? {};
  return new De(
    Vn(n, r),
    // (XXX): LinksDef<any> stems from TypeScript's inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    r,
    s
  );
}
const E = {
  // constructs
  graph: lo,
  schema: wo,
  entity: fo,
  // value types
  string: ho,
  number: po,
  boolean: yo,
  date: bo,
  json: go,
  any: _o
};
let Te;
function To(n, e) {
  Te == null || Te.dispose();
  const t = ko(e), r = Ao(e, a), s = So(mo(n));
  function i(l) {
    var f;
    l.source === s.element.contentWindow && ((f = l.data) == null ? void 0 : f.type) === "close" && t.isVisible() && a();
  }
  function o(l) {
    const f = l.shiftKey && l.ctrlKey && l.key === "0", d = l.key === "Escape" || l.key === "Esc";
    (f || d && t.isVisible()) && a();
  }
  function a() {
    t.isVisible() ? t.element.style.display = "none" : (t.element.style.display = "block", t.element.contains(s.element) || t.element.appendChild(s.element));
  }
  function c() {
    t.element.remove(), r.element.remove(), removeEventListener("keydown", o), removeEventListener("message", i);
  }
  function u() {
    document.body.appendChild(t.element), document.body.appendChild(r.element), addEventListener("keydown", o), addEventListener("message", i), Te = {
      dispose: c
    };
  }
  return u();
}
function mo(n) {
  return `${_t || Rn ? "http://localhost:3000" : "https://instantdb.com"}/_devtool?appId=${n}`;
}
function So(n) {
  const e = document.createElement("iframe");
  return e.src = n, e.className = "instant-devtool-iframe", Object.assign(e.style, {
    width: "100%",
    height: "100%",
    backgroundColor: "white",
    border: "none"
  }), { element: e };
}
function Ao(n, e) {
  const t = `
    <svg width="32" height="32" viewBox="0 0 512 512" fill="none" xmlns="http://www.w3.org/2000/svg">
      <rect width="512" height="512" fill="black"/>
      <rect x="97.0973" y="91.3297" width="140" height="330" fill="white"/>
    </svg>
  `, r = document.createElement("button");
  return r.innerHTML = t, r.className = "instant-devtool-toggler", Object.assign(r.style, {
    // pos
    position: "fixed",
    ...Oo(n.position),
    height: "32px",
    width: "32px",
    // layout
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    zIndex: "9010",
    // look
    padding: "0",
    margin: "0",
    border: "none",
    cursor: "pointer"
  }), r.addEventListener("click", e), { element: r };
}
function Oo(n) {
  switch (n) {
    case "bottom-left":
      return { bottom: "24px", left: "24px" };
    case "bottom-right":
      return { bottom: "24px", right: "24px" };
    case "top-right":
      return { top: "24px", right: "24px" };
    case "top-left":
      return { top: "24px", left: "24px" };
  }
}
function vo(n) {
  switch (n) {
    case "bottom-left":
      return { bottom: "24px", right: "24px", left: "60px", top: "72px" };
    case "bottom-right":
      return { bottom: "24px", left: "24px", right: "60px", top: "72px" };
    case "top-right":
      return { top: "24px", left: "24px", right: "60px", bottom: "72px" };
    case "top-left":
      return { top: "24px", right: "24px", left: "60px", bottom: "72px" };
  }
}
function ko(n) {
  const e = document.createElement("div");
  Object.assign(e.style, {
    position: "fixed",
    ...vo(n.position),
    display: "block",
    borderRadius: "4px",
    border: "1px #ccc solid",
    boxShadow: "0px 0px 8px #00000044",
    backgroundColor: "#eee",
    zIndex: "999990"
  }), e.style.display = "none", e.className = "instant-devtool-container";
  function t() {
    return e.style.display !== "none";
  }
  return { element: e, isVisible: t };
}
function Eo(n, e) {
  return e && e.refresh_token ? new Response(JSON.stringify({ ok: !0 }), {
    headers: {
      "Content-Type": "application/json",
      // 7 day expiry
      "Set-Cookie": `instant_user_${n.appId}=${JSON.stringify(e)}; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=604800`
    }
  }) : new Response(JSON.stringify({ ok: !0 }), {
    headers: {
      "Content-Type": "application/json",
      // remove the cookie (some browsers)
      "Set-Cookie": `instant_user_${n.appId}=; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=-1`
    }
  });
}
function me(n, e) {
  return new Response(JSON.stringify({ ok: !1, error: e }), {
    status: n,
    headers: { "Content-Type": "application/json" }
  });
}
const Ko = (n) => ({
  POST: async (e) => {
    let t;
    try {
      t = await e.json();
    } catch {
      return me(400, "Invalid JSON body");
    }
    if (!t.type)
      return me(400, 'Missing "type" field');
    if (t.appId !== n.appId)
      return me(403, "App ID mismatch");
    switch (t.type) {
      case "sync-user":
        return Eo(n, t.user ?? null);
      default:
        return me(400, `Unknown type: ${t.type}`);
    }
  }
}), zo = (n) => {
  var i, o, a, c, u, l;
  const e = {};
  for (const [f, d] of Object.entries(n.entities)) {
    const h = d, p = {};
    for (const [b, _] of Object.entries(h.attrs)) {
      const g = _;
      let y;
      switch (g.valueType) {
        case "string":
          y = E.string();
          break;
        case "number":
          y = E.number();
          break;
        case "boolean":
          y = E.boolean();
          break;
        case "date":
          y = E.date();
          break;
        case "json":
          y = E.json();
          break;
        default:
          y = E.json();
      }
      g.required || (y = y.optional()), (i = g.config) != null && i.indexed && (y = y.indexed()), (o = g.config) != null && o.unique && (y = y.unique()), p[b] = y;
    }
    e[f] = E.entity(p);
  }
  const t = n.links || {}, r = {};
  if (n.rooms)
    for (const [f, d] of Object.entries(n.rooms)) {
      const h = d, p = {};
      for (const [_, g] of Object.entries(
        h.presence.attrs
      )) {
        const y = g;
        let w;
        switch (y.valueType) {
          case "string":
            w = E.string();
            break;
          case "number":
            w = E.number();
            break;
          case "boolean":
            w = E.boolean();
            break;
          case "date":
            w = E.date();
            break;
          case "json":
            w = E.json();
            break;
          default:
            w = E.json();
        }
        y.required || (w = w.optional()), (a = y.config) != null && a.indexed && (w = w.indexed()), (c = y.config) != null && c.unique && (w = w.unique()), p[_] = w;
      }
      const b = {};
      if (h.topics)
        for (const [_, g] of Object.entries(h.topics)) {
          const y = g, w = {};
          for (const [S, m] of Object.entries(y.attrs)) {
            const v = m;
            let O;
            switch (v.valueType) {
              case "string":
                O = E.string();
                break;
              case "number":
                O = E.number();
                break;
              case "boolean":
                O = E.boolean();
                break;
              case "date":
                O = E.date();
                break;
              case "json":
                O = E.json();
                break;
              default:
                O = E.json();
            }
            v.required || (O = O.optional()), (u = v.config) != null && u.indexed && (O = O.indexed()), (l = v.config) != null && l.unique && (O = O.unique()), w[S] = O;
          }
          b[_] = E.entity(w);
        }
      r[f] = {
        presence: E.entity(p),
        topics: b
      };
    }
  return E.schema({
    entities: e,
    links: t,
    rooms: r
  });
}, Io = typeof window > "u" || "Deno" in globalThis;
class Vo {
  constructor(e) {
    this.resultMap = /* @__PURE__ */ new Map(), this.queryResolvedCallbacks = [], this.subscribe = (t) => {
      this.queryResolvedCallbacks.push(t);
    }, this.addQueryResult = (t, r) => {
      this.resultMap.set(t, {
        type: r.type,
        status: "success",
        data: r,
        promise: null,
        error: null
      }), Io || (this.db._reactor.attrs || this.db._reactor._setAttrs(r.attrs), this.db._reactor._addQueryData(
        r.query,
        r,
        !!this.db._reactor.config.schema
      ));
    }, this.query = (t, r) => {
      const { hash: s, query: i } = this.hashQuery(t, r);
      if (this.db._reactor.status === "authenticated") {
        const c = this.db.queryOnce(t, r);
        let u = {
          status: "pending",
          type: "session",
          data: void 0,
          error: void 0,
          promise: c
        };
        return c.then((l) => {
          u.status = "success", u.data = l, u.promise = null;
        }), c.catch((l) => {
          u.status = "error", u.error = l, u.promise = null;
        }), this.resultMap.set(s, u), u;
      }
      const o = this.getTriplesAndAttrsForQuery(i);
      let a = {
        status: "pending",
        type: "http",
        data: void 0,
        error: void 0,
        promise: o
      };
      return o.then((c) => {
        a.status = "success", a.data = c, a.promise = null;
      }), o.catch((c) => {
        a.status = "error", a.error = c, a.promise = null;
      }), o.then((c) => {
        this.queryResolvedCallbacks.forEach((u) => {
          u({
            queryHash: s,
            query: i,
            attrs: c.attrs,
            triples: c.triples,
            pageInfo: c.pageInfo
          });
        });
      }), this.resultMap.set(s, a), a;
    }, this.getExistingResultForQuery = (t, r) => {
      const { hash: s } = this.hashQuery(t, r);
      return this.resultMap.get(s);
    }, this.completeIsomorphic = (t, r, s, i) => {
      var f, d, h, p, b, _, g, y;
      const o = {};
      s.forEach((w) => {
        o[w.id] = w;
      });
      const a = !!((h = (d = (f = this.db) == null ? void 0 : f._reactor) == null ? void 0 : d.config) != null && h.schema) && ("cardinalityInference" in ((b = (p = this.db) == null ? void 0 : p._reactor) == null ? void 0 : b.config) ? !!((g = (_ = this.db) == null ? void 0 : _._reactor.config) != null && g.cardinalityInference) : !0), c = new H(
        s.reduce((w, S) => (w[S.id] = S, w), {}),
        rt((y = this.db) == null ? void 0 : y._reactor.config.schema)
      ), u = te(
        c,
        r,
        a,
        this.params.db._reactor.config.useDateObjects || !1
      );
      return gt(
        {
          store: u,
          attrsStore: c,
          pageInfo: i,
          aggregate: void 0
        },
        t
      );
    }, this.hashQuery = (t, r) => {
      t && r && "ruleParams" in r && (t = { $$ruleParams: r.ruleParams, ...t });
      const s = t ? Do(t) : null;
      return { hash: M(s), query: s };
    }, this.getTriplesAndAttrsForQuery = async (t) => {
      var r, s, i, o, a, c;
      try {
        const u = await fetch(
          `${this.db._reactor.config.apiURI}/runtime/framework/query`,
          {
            method: "POST",
            headers: {
              "app-id": this.params.db._reactor.config.appId,
              "Content-Type": "application/json",
              Authorization: this.params.token ? `Bearer ${this.params.token}` : void 0
            },
            body: JSON.stringify({
              query: t
            })
          }
        );
        if (!u.ok)
          throw new Error("Error getting triples from server");
        const l = await u.json(), f = l == null ? void 0 : l.attrs;
        if (!f)
          throw new Error("No attrs");
        const d = (i = (s = (r = l.result) == null ? void 0 : r[0].data) == null ? void 0 : s["datalog-result"]) == null ? void 0 : i["join-rows"][0], h = (c = (a = (o = l.result) == null ? void 0 : o[0]) == null ? void 0 : a.data) == null ? void 0 : c["page-info"];
        return {
          attrs: f,
          triples: d,
          type: "http",
          queryHash: this.hashQuery(t).hash,
          query: t,
          pageInfo: h
        };
      } catch (u) {
        const l = new Error(
          "Error getting triples from framework client"
        );
        throw l.cause = u, l;
      }
    }, this.params = e, this.db = e.db, this.resultMap = /* @__PURE__ */ new Map();
  }
}
const Co = {
  apiURI: "https://api.instantdb.com",
  websocketURI: "wss://api.instantdb.com/runtime/session"
};
function Mo() {
  return globalThis.__instantDbSchemaHashStore = globalThis.__instantDbSchemaHashStore ?? /* @__PURE__ */ new WeakMap(), globalThis.__instantDbSchemaHashStore;
}
function Po() {
  return globalThis.__instantDbStore = globalThis.__instantDbStore ?? {}, globalThis.__instantDbStore;
}
function st(n) {
  const e = n.__adminToken;
  return n.appId + "_" + (n.websocketURI || "default_ws_uri") + "_" + (n.apiURI || "default_api_uri") + "_" + (e || "client_only") + "_" + n.useDateObjects;
}
const it = Po(), en = Mo();
class jo {
  constructor(e) {
    this.db = e, this.sendMagicCode = (t) => this.db.sendMagicCode(t), this.signInWithMagicCode = (t) => this.db.signInWithMagicCode(t), this.signInWithToken = (t) => this.db.signInWithCustomToken(t), this.signInAsGuest = () => this.db.signInAsGuest(), this.createAuthorizationURL = (t) => this.db.createAuthorizationURL(t), this.signInWithIdToken = (t) => this.db.signInWithIdToken(t), this.exchangeOAuthCode = (t) => this.db.exchangeCodeForToken(t), this.issuerURI = () => this.db.issuerURI(), this.signOut = (t = { invalidateToken: !0 }) => this.db.signOut(t);
  }
}
class $o {
  constructor(e) {
    this.db = e, this.uploadFile = (t, r, s = {}) => this.db.uploadFile(t, r, s), this.delete = (t) => this.db.deleteFile(t), this.upload = (t, r) => this.db.upload(t, r), this.put = this.upload, this.getDownloadUrl = (t) => this.db.getDownloadUrl(t);
  }
}
function Do(n) {
  return JSON.parse(JSON.stringify(n));
}
class Ro {
  constructor(e) {
    this.tx = Cn(), this._reactor = e, this.auth = new jo(this._reactor), this.storage = new $o(this._reactor);
  }
  /**
   * Use this to write data! You can create, update, delete, and link objects
   *
   * @see https://instantdb.com/docs/instaml
   *
   * @example
   *   // Create a new object in the `goals` namespace
   *   const goalId = id();
   *   db.transact(db.tx.goals[goalId].update({title: "Get fit"}))
   *
   *   // Update the title
   *   db.transact(db.tx.goals[goalId].update({title: "Get super fit"}))
   *
   *   // Delete it
   *   db.transact(db.tx.goals[goalId].delete())
   *
   *   // Or create an association:
   *   todoId = id();
   *   db.transact([
   *    db.tx.todos[todoId].update({ title: 'Go on a run' }),
   *    db.tx.goals[goalId].link({todos: todoId}),
   *  ])
   */
  transact(e) {
    return this._reactor.pushTx(e);
  }
  getLocalId(e) {
    return this._reactor.getLocalId(e);
  }
  /**
   * Use this to query your data!
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *  // listen to all goals
   *  db.subscribeQuery({ goals: {} }, (resp) => {
   *    console.log(resp.data.goals)
   *  })
   *
   *  // goals where the title is "Get Fit"
   *  db.subscribeQuery(
   *    { goals: { $: { where: { title: "Get Fit" } } } },
   *    (resp) => {
   *      console.log(resp.data.goals)
   *    }
   *  )
   *
   *  // all goals, _alongside_ their todos
   *  db.subscribeQuery({ goals: { todos: {} } }, (resp) => {
   *    console.log(resp.data.goals)
   *  });
   */
  subscribeQuery(e, t, r) {
    return this._reactor.subscribeQuery(e, t, r);
  }
  /**
   * Listen for the logged in state. This is useful
   * for deciding when to show a login screen.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const unsub = db.subscribeAuth((auth) => {
   *     if (auth.user) {
   *     console.log('logged in as', auth.user.email)
   *    } else {
   *      console.log('logged out')
   *    }
   *  })
   */
  subscribeAuth(e) {
    return this._reactor.subscribeAuth(e);
  }
  /**
   * One time query for the logged in state. This is useful
   * for scenarios where you want to know the current auth
   * state without subscribing to changes.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const user = await db.getAuth();
   *   console.log('logged in as', user.email)
   */
  getAuth() {
    return this._reactor.getAuth();
  }
  /**
   * Listen for connection status changes to Instant. This is useful
   * for building things like connectivity indicators
   *
   * @see https://www.instantdb.com/docs/patterns#connection-status
   * @example
   *   const unsub = db.subscribeConnectionStatus((status) => {
   *     const connectionState =
   *       status === 'connecting' || status === 'opened'
   *         ? 'authenticating'
   *       : status === 'authenticated'
   *         ? 'connected'
   *       : status === 'closed'
   *         ? 'closed'
   *       : status === 'errored'
   *         ? 'errored'
   *       : 'unexpected state';
   *
   *     console.log('Connection status:', connectionState);
   *   });
   */
  subscribeConnectionStatus(e) {
    return this._reactor.subscribeConnectionStatus(e);
  }
  /**
   * Join a room to publish and subscribe to topics and presence.
   *
   * @see https://instantdb.com/docs/presence-and-topics
   * @example
   * // init
   * const db = init();
   * const room = db.joinRoom(roomType, roomId);
   * // usage
   * const unsubscribeTopic = room.subscribeTopic("foo", console.log);
   * const unsubscribePresence = room.subscribePresence({}, console.log);
   * room.publishTopic("hello", { message: "hello world!" });
   * room.publishPresence({ name: "joe" });
   * // later
   * unsubscribePresence();
   * unsubscribeTopic();
   * room.leaveRoom();
   */
  joinRoom(e = "_defaultRoomType", t = "_defaultRoomId", r) {
    return {
      leaveRoom: this._reactor.joinRoom(t, r == null ? void 0 : r.initialPresence),
      subscribeTopic: (i, o) => this._reactor.subscribeTopic(t, i, o),
      subscribePresence: (i, o) => this._reactor.subscribePresence(e, t, i, o),
      publishTopic: (i, o) => this._reactor.publishTopic({ roomType: e, roomId: t, topic: i, data: o }),
      publishPresence: (i) => this._reactor.publishPresence(e, t, i),
      getPresence: (i) => this._reactor.getPresence(e, t, i)
    };
  }
  shutdown() {
    delete it[st(this._reactor.config)], this._reactor.shutdown();
  }
  /**
   * Use this for one-off queries.
   * Returns local data if available, otherwise fetches from the server.
   * Because we want to avoid stale data, this method will throw an error
   * if the user is offline or there is no active connection to the server.
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *
   *  const resp = await db.queryOnce({ goals: {} });
   *  console.log(resp.data.goals)
   */
  queryOnce(e, t) {
    return this._reactor.queryOnce(e, t);
  }
  /**
   * @deprecated This is an experimental function that is not yet ready for production use.
   * Use this function to sync an entire namespace.
   * It has many limitations that will be removed in the future:
   * 1. Must be used with an admin token
   * 2. Does not support permissions
   * 3. Does not support where clauses
   * 4. Does not support links
   * It also does not support multiple top-level namespaces. For example,
   *  {posts: {}, users: {}} is invalid. Only `posts` or `users` is allowed, but not both.
   */
  _syncTableExperimental(e, t) {
    return this._reactor.subscribeTable(e, t);
  }
}
function tn(n) {
  if (!n)
    return "0";
  const e = en.get(n);
  if (e)
    return e;
  const t = M(n);
  return en.set(n, t), t;
}
function xo(n, e) {
  return tn(n._reactor.config.schema) !== tn(e);
}
function Uo(n, e, t, r, s) {
  var u;
  const i = {
    ...n,
    appId: (u = n.appId) == null ? void 0 : u.trim(),
    useDateObjects: n.useDateObjects ?? !1
  }, o = it[st(i)];
  if (o)
    return xo(o, i.schema) && o._reactor.updateSchema(i.schema), o;
  const a = new uo(
    {
      ...Co,
      ...i,
      cardinalityInference: !!i.schema
    },
    e || jn,
    t || $n,
    { ...r || {}, "@instantdb/core": Un },
    s
  ), c = new Ro(a);
  return it[st(i)] = c, Lo(i.appId, i.devtool), c;
}
function Lo(n, e) {
  if (typeof window > "u" || typeof window.location > "u" || typeof document > "u" || typeof e == "boolean" && !e)
    return;
  const t = {
    position: "bottom-right",
    allowedHosts: ["localhost"],
    ...typeof e == "object" ? e : {}
  };
  t.allowedHosts.includes(window.location.hostname) && To(n, t);
}
const Qo = Uo;
export {
  jo as Auth,
  Vo as FrameworkClient,
  jn as IndexedDBStorage,
  je as InstantAPIError,
  Ro as InstantCoreDatabase,
  pe as InstantError,
  k as QueryValidationError,
  $o as Storage,
  di as StorageInterface,
  Hi as SyncTableCallbackEventType,
  q as TransactionValidationError,
  $n as WindowNetworkListener,
  Do as coerceQuery,
  Me as coerceToDate,
  Ko as createInstantRouteHandler,
  Ns as getOps,
  E as i,
  P as id,
  Uo as init,
  Qo as init_experimental,
  Fo as lookup,
  zo as parseSchemaFromJSON,
  qo as tx,
  Cn as txInit,
  Wt as validateQuery,
  qi as validateTransactions,
  Un as version,
  M as weakHash
};
