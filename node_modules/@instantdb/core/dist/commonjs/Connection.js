"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SSEConnection = exports.WSConnection = void 0;
let _connId = 0;
class WSConnection {
    constructor(url) {
        this.type = 'ws';
        this.id = `${this.type}_${_connId++}`;
        this.conn = new WebSocket(url);
        this.conn.onopen = (_e) => {
            if (this.onopen) {
                this.onopen({ target: this });
            }
        };
        this.conn.onmessage = (e) => {
            if (this.onmessage) {
                this.onmessage({
                    target: this,
                    message: JSON.parse(e.data.toString()),
                });
            }
        };
        this.conn.onclose = (_e) => {
            if (this.onclose) {
                this.onclose({ target: this });
            }
        };
        this.conn.onerror = (_e) => {
            if (this.onerror) {
                this.onerror({ target: this });
            }
        };
    }
    close() {
        this.conn.close();
    }
    isOpen() {
        var _a;
        return this.conn.readyState === ((_a = WebSocket.OPEN) !== null && _a !== void 0 ? _a : 1);
    }
    isConnecting() {
        var _a;
        return this.conn.readyState === ((_a = WebSocket.CONNECTING) !== null && _a !== void 0 ? _a : 0);
    }
    send(msg) {
        return this.conn.send(JSON.stringify(msg));
    }
}
exports.WSConnection = WSConnection;
class SSEConnection {
    constructor(ES, url) {
        this.type = 'sse';
        this.initParams = null;
        this.sendQueue = [];
        this.closeFired = false;
        this.sseInitTimeout = undefined;
        this.id = `${this.type}_${_connId++}`;
        this.url = url;
        this.ES = ES;
        this.conn = new ES(url);
        // Close the connection if we didn't get an init within 10 seconds
        this.sseInitTimeout = setTimeout(() => {
            if (!this.initParams) {
                this.handleError();
            }
        }, 10000);
        this.conn.onmessage = (e) => {
            const message = JSON.parse(e.data);
            if (Array.isArray(message)) {
                for (const msg of message) {
                    this.handleMessage(msg);
                }
            }
            else {
                this.handleMessage(message);
            }
        };
        this.conn.onerror = (e) => {
            this.handleError();
        };
    }
    handleMessage(msg) {
        if (msg.op === 'sse-init') {
            this.initParams = {
                machineId: msg['machine-id'],
                sessionId: msg['session-id'],
                sseToken: msg['sse-token'],
            };
            if (this.onopen) {
                this.onopen({ target: this });
            }
            clearTimeout(this.sseInitTimeout);
            return;
        }
        if (this.onmessage) {
            this.onmessage({
                target: this,
                message: msg,
            });
        }
    }
    // Runs the onerror and closes the connection
    handleError() {
        try {
            if (this.onerror) {
                this.onerror({ target: this });
            }
        }
        finally {
            this.handleClose();
        }
    }
    handleClose() {
        this.conn.close();
        if (this.onclose && !this.closeFired) {
            this.closeFired = true;
            this.onclose({ target: this });
        }
    }
    postMessages(messages) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            try {
                const resp = yield fetch(this.url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        machine_id: (_a = this.initParams) === null || _a === void 0 ? void 0 : _a.machineId,
                        session_id: (_b = this.initParams) === null || _b === void 0 ? void 0 : _b.sessionId,
                        sse_token: (_c = this.initParams) === null || _c === void 0 ? void 0 : _c.sseToken,
                        messages,
                    }),
                });
                if (!resp.ok) {
                    this.handleError();
                }
            }
            catch (e) {
                this.handleError();
            }
        });
    }
    flushQueue() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.sendPromise || !this.sendQueue.length)
                return;
            const messages = this.sendQueue;
            this.sendQueue = [];
            const sendPromise = this.postMessages(messages);
            this.sendPromise = sendPromise;
            sendPromise.then(() => {
                this.sendPromise = null;
                this.flushQueue();
            });
        });
    }
    send(msg) {
        if (!this.isOpen() || !this.initParams) {
            if (this.isConnecting()) {
                throw new Error(`Failed to execute 'send' on 'EventSource': Still in CONNECTING state.`);
            }
            if (this.conn.readyState === this.ES.CLOSED) {
                throw new Error(`EventSource is already in CLOSING or CLOSED state.`);
            }
            throw new Error(`EventSource is in invalid state.`);
        }
        this.sendQueue.push(msg);
        this.flushQueue();
    }
    isOpen() {
        return this.conn.readyState === this.ES.OPEN && this.initParams !== null;
    }
    isConnecting() {
        return (this.conn.readyState === this.ES.CONNECTING ||
            (this.conn.readyState === this.ES.OPEN && this.initParams === null));
    }
    close() {
        this.handleClose();
    }
}
exports.SSEConnection = SSEConnection;
//# sourceMappingURL=Connection.js.map