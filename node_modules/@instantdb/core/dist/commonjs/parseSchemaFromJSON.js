"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseSchemaFromJSON = void 0;
const schema_ts_1 = require("./schema.js");
const parseSchemaFromJSON = (s) => {
    var _a, _b, _c, _d, _e, _f;
    // Parse entities
    const entities = {};
    for (const [entityName, entityInfo] of Object.entries(s.entities)) {
        const entityDef = entityInfo;
        const attrs = {};
        // Parse attributes
        for (const [attrName, attrInfo] of Object.entries(entityDef.attrs)) {
            const attrDef = attrInfo;
            let attr;
            // Create the appropriate attribute type
            switch (attrDef.valueType) {
                case 'string':
                    attr = schema_ts_1.i.string();
                    break;
                case 'number':
                    attr = schema_ts_1.i.number();
                    break;
                case 'boolean':
                    attr = schema_ts_1.i.boolean();
                    break;
                case 'date':
                    attr = schema_ts_1.i.date();
                    break;
                case 'json':
                    attr = schema_ts_1.i.json();
                    break;
                default:
                    attr = schema_ts_1.i.json();
            }
            // Apply modifiers
            if (!attrDef.required) {
                attr = attr.optional();
            }
            if ((_a = attrDef.config) === null || _a === void 0 ? void 0 : _a.indexed) {
                attr = attr.indexed();
            }
            if ((_b = attrDef.config) === null || _b === void 0 ? void 0 : _b.unique) {
                attr = attr.unique();
            }
            attrs[attrName] = attr;
        }
        entities[entityName] = schema_ts_1.i.entity(attrs);
    }
    // Parse links
    const links = s.links || {};
    // Parse rooms
    const rooms = {};
    if (s.rooms) {
        for (const [roomName, roomInfo] of Object.entries(s.rooms)) {
            const roomDef = roomInfo;
            // Parse presence
            const presenceAttrs = {};
            for (const [attrName, attrInfo] of Object.entries(roomDef.presence.attrs)) {
                const attrDef = attrInfo;
                let attr;
                switch (attrDef.valueType) {
                    case 'string':
                        attr = schema_ts_1.i.string();
                        break;
                    case 'number':
                        attr = schema_ts_1.i.number();
                        break;
                    case 'boolean':
                        attr = schema_ts_1.i.boolean();
                        break;
                    case 'date':
                        attr = schema_ts_1.i.date();
                        break;
                    case 'json':
                        attr = schema_ts_1.i.json();
                        break;
                    default:
                        attr = schema_ts_1.i.json();
                }
                if (!attrDef.required) {
                    attr = attr.optional();
                }
                if ((_c = attrDef.config) === null || _c === void 0 ? void 0 : _c.indexed) {
                    attr = attr.indexed();
                }
                if ((_d = attrDef.config) === null || _d === void 0 ? void 0 : _d.unique) {
                    attr = attr.unique();
                }
                presenceAttrs[attrName] = attr;
            }
            // Parse topics
            const topics = {};
            if (roomDef.topics) {
                for (const [topicName, topicInfo] of Object.entries(roomDef.topics)) {
                    const topicDef = topicInfo;
                    const topicAttrs = {};
                    for (const [attrName, attrInfo] of Object.entries(topicDef.attrs)) {
                        const attrDef = attrInfo;
                        let attr;
                        switch (attrDef.valueType) {
                            case 'string':
                                attr = schema_ts_1.i.string();
                                break;
                            case 'number':
                                attr = schema_ts_1.i.number();
                                break;
                            case 'boolean':
                                attr = schema_ts_1.i.boolean();
                                break;
                            case 'date':
                                attr = schema_ts_1.i.date();
                                break;
                            case 'json':
                                attr = schema_ts_1.i.json();
                                break;
                            default:
                                attr = schema_ts_1.i.json();
                        }
                        if (!attrDef.required) {
                            attr = attr.optional();
                        }
                        if ((_e = attrDef.config) === null || _e === void 0 ? void 0 : _e.indexed) {
                            attr = attr.indexed();
                        }
                        if ((_f = attrDef.config) === null || _f === void 0 ? void 0 : _f.unique) {
                            attr = attr.unique();
                        }
                        topicAttrs[attrName] = attr;
                    }
                    topics[topicName] = schema_ts_1.i.entity(topicAttrs);
                }
            }
            rooms[roomName] = {
                presence: schema_ts_1.i.entity(presenceAttrs),
                topics,
            };
        }
    }
    const resultingSchema = schema_ts_1.i.schema({
        entities,
        links,
        rooms,
    });
    return resultingSchema;
};
exports.parseSchemaFromJSON = parseSchemaFromJSON;
//# sourceMappingURL=parseSchemaFromJSON.js.map